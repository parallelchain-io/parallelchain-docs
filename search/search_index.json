{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the ParallelChain Mainnet Documentation","text":"<p>This documentation website aims to provide you with a comprehensive understanding of the ParallelChain Mainnet ecosystem, including its architecture, programming model, and tools.</p> <p>The content of this guide covers topics ranging from setting up your development environment to building, deploying and verifying smart contracts on the ParallelChain Mainnet network.</p> <p>In this guide, you will learn:</p> <ul> <li>Basics of ParallelChain Mainnet architecture and programming model</li> <li>Basic concepts and terms encountered in ParallelChain Mainnet</li> <li>How to use tools provided by ParallelChain, including <code>pchain-client</code>, <code>pchain-sdk</code> etc</li> <li>How to set up a development environment</li> <li>How to deploy smart contracts and interact with them using the command-line interface and SDK</li> </ul> <p>Whether you are a seasoned blockchain developer or just getting started with smart contract development, our Web Guide provides all the resources you need to start building on the ParallelChain Mainnet network.</p> <p>Let's get started!</p>","tags":["ParallelChain"]},{"location":"#contact-us","title":"Contact us","text":"<p>If you are interested in ParallelChain Mainnet, reach out on us from our Official Telegram Group or Discord channel. </p>","tags":["ParallelChain"]},{"location":"introduction/","title":"Introduction","text":"","tags":["ParallelChain","Mainnet"]},{"location":"introduction/#what-is-parallelchain","title":"What is ParallelChain","text":"<p>ParallelChain is a Layer-1 proof-of-stake public blockchain platform that places digital identity at its core, empowering the decentralised web and its users with trusted identities that users fully own, control, and have the power to monetise. </p> <p>Integrated with BINGO, an AI-powered identity verification platform, and cutting-edge privacy technologies, ParallelChain brings trusted digital identities on-chain and facilitates anonymous verification without intermediaries. This model not only enhances user privacy but also ensures compliance with stringent data protection regulations like GDPR, empowering decentralised applications (DApps) with compliance readiness.</p> <p>ParallelChain has a strong focus on security, scalability and interoperability. It aims to provide a robust identity system for developers of every blockchain to build more secure and compliant applications.</p>","tags":["ParallelChain","Mainnet"]},{"location":"introduction/#digital-identity-reinvented","title":"Digital Identity Reinvented","text":"<p>ParallelChain is engineered to provide a secure and user-centric digital identity framework. By embracing self-sovereign identity (SSI), users can issue, manage, and revoke identity credentials without relying on centralized authorities. This decentralized approach fosters greater privacy and data ownership, allowing individuals to selectively share personal information with third parties while keeping sensitive details private. ParallelChain\u2019s Verifiable Credentials system, anchored on the blockchain, ensures that identity attestations are tamper-proof and can be verified instantly in real-time across multiple platforms.</p> <p>The SSI model removes reliance on centralized identity systems, reducing risks such as hacking and unauthorized access to data. It also supports seamless cross-border identity verification, streamlining processes in industries like finance, healthcare, and e-commerce where secure digital identities are critical. By combining Zero-Knowledge Proofs (ZKPs) with advanced cryptographic techniques, ParallelChain allows for identity verification without exposing unnecessary personal information, creating a privacy-first ecosystem that remains compliant with stringent regulations like GDPR and other global data protection laws.</p> <p>ParallelChain also integrates BINGO, an AI-powered identity engine that supports one-to-many and one-to-one biometric verification. This makes the platform highly suitable for applications that require secure and real-time identity validation, such as financial services, healthcare, and government institutions.</p>","tags":["ParallelChain","Mainnet"]},{"location":"introduction/#what-is-xpll","title":"What is XPLL","text":"<p>XPLL is the native utility token of ParallelChain Mainnet (TXPLL in Testnet). It is used to pay for transaction fees, participate in staking, and engage in network governance. XPLL operates within a Delegated Proof-of-Stake (DPoS) consensus mechanism, which ensures network integrity and security. Users pay transaction fees in GRAY, the smallest unit of XPLL, where 1 GRAY = 0.00000001 XPLL.</p> <p>XPLL also plays a key role in incentivizing network validators and participants to maintain security and efficiency, while punishing any malicious activity that threatens the network\u2019s stability. Validator nodes stake XPLL to process transactions, contributing to the network's decentralization.</p> <p>The goal of defining a denomination for XPLL is to standardize its scale with all currencies in the financial system. The table below shows the different denominations of XPLL, their abbreviations, and their equivalent values in terms of XPLL.</p> Denomination Abbreviation Value in XPLL Gray Gr 0.00000001 XPLL KiloGray KGr 0.00001 XPLL MegaGray MGr 0.01 XPLL XPLL XPLL 1 XPLL TeraGray TGr 10000 XPLL PetaGray PGr 10000000 XPLL <p>Gray is named in honor of James Nicholas Gray, a renowned computer scientist who was considered a pioneer in modern database technology. He was the award winner of the prestigious ACM Turing Award in 1998, which is the highest distinction in the field of computer science.</p>","tags":["ParallelChain","Mainnet"]},{"location":"introduction/#how-to-get-xpll","title":"How to Get XPLL","text":"<p>XPLL can be acquired through several channels:</p> <ul> <li> <p>Staking Rewards: Users can stake XPLL by delegating it to validators, securing the network while earning additional XPLL as rewards. To learn more about staking, read Staking.</p> </li> <li> <p>Exchanges: XPLL can be purchased on exchanges that support the ParallelChain ecosystem.</p> <ul> <li>Gate.io</li> <li>Biconomy.com</li> <li>Letsexchange.io</li> </ul> </li> <li> <p>Participating in the Ecosystem: Developers, validators, and ecosystem participants can earn XPLL through their contributions to the network, including running nodes, participating in governance, or building decentralized applications (dApps).</p> </li> </ul>","tags":["ParallelChain","Mainnet"]},{"location":"introduction/#parallelchain-foundation","title":"ParallelChain Foundation","text":"<p>The continued development of ParallelChain is supported by the ParallelChain Foundation, an independent governance body based in Switzerland, and it is dedicated to increasing awareness and growing a strong builder community for ParallelChain.</p>","tags":["ParallelChain","Mainnet"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/","title":"JavaScript APIs","text":"<p>ParallelChain RPC APIs are the HTTP APIs that Fullnodes make available to clients. </p> <p>In the section ParallelChain Client Library, we introduce the Javascript Library to make RPC calls programatically. </p> <p>The Client Library allows you to easily submit RPC requests and parse RPC responses without the need to understand the details of HTTP URL, request format or response format. The formation of HTTP APIs is specified in ParallelChain Protocol.</p>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#parallelchain-client-library-javascript","title":"ParallelChain Client Library (Javascript)","text":"<p>ParallelChain Client Library is a Javascript package providing a HTTP client for interacting with the ParallelChain RPC APIs. We will show how to use the library by example code that runs in Node.js. To use the library, install the npm package pchain-client-js. You will also need the package pchain-types-js for necessary basic types.</p> <pre><code>npm install pchain-client-js\nnpm install pchain-types-js\n</code></pre> <p>You can instantiate the object <code>Client</code> by providing the link to a ParallelChain RPC endpoint. Let's start with a simple Node.js script as below.</p> <pre><code>const Client = require(\"pchain-client-js\").Client;\n\n(async () =&gt; {\n    /// Connect to Testnet RPC endpoint\n    const client = new Client('https://pchain-test-rpc02.parallelchain.io');\n    /// ...\n})();\n</code></pre> <p>Note</p> <p>RPC endpoints for Mainnet and Testnet are <code>https://pchain-main-rpc02.parallelchain.io</code> and <code>https://pchain-test-rpc02.parallelchain.io</code> respectively.</p>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#understanding-basic-types","title":"Understanding Basic Types","text":"<p>Throughout the API Reference, basic types provided by pchain-type-js are often being used in the RPC requests and responses. For better understanding their data, Let's go through them.  </p> <p>First, the integer types <code>u16</code>, <code>u32</code> and <code>u64</code> are type-alias to types <code>number</code>, <code>number</code> and BN in typescript respectively.</p> <p>The class <code>Option&lt;T&gt;</code> contains a value with type <code>T</code> or value of null.</p> <p>The classes <code>Sha256Hash</code> and <code>PublicAddress</code> store a data <code>Buffer</code>. They are similar in the way that they can be instantiated from a Base64URL encoded string.</p> <pre><code>// Instantiates a PublicAddress Object by passing the 32-byte address in base64url encoded string.\nconst public_address = new PublicAddress('oK8Kvd-2cWYloQaPNlGtG3Q5dV6JFKzVrXOAhBRt5hs');\n// Instantiates a Sha256Hash Object by passing the Sha256 hash in base64url encoded string.\nconst sha256_hash = new Sha256Hash('x96G2mLXgaCNaAABXNICWHh_DH33khSg_T7UawTGnGg');\n</code></pre> <p>The abstract class <code>Enum</code> functions as the enum in Rust Programming Language so that the inherited class can be used and serialized as requred by ParallelChain RPC API. An example is ValidatorSet.</p> <p>The class extends the <code>Enum</code> and provides two variants. <pre><code>class ValidatorSet extends Enum {\n    poolsWithDelegator?: PoolWithDelegator[];\n    poolsWithoutDelegator?: PoolWithoutDelegator[];\n}\n</code></pre></p> <p>Example to get the object of <code>PoolWithoutDelegator</code>:</p> <pre><code>const validatorSet = // an object of ValidaterSet\nconst poolsWithoutDelegator = validatorSet?.poolsWithoutDelegator || [];\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#transaction-related-rpcs","title":"Transaction Related RPCs","text":"","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#submit_transaction","title":"submit_transaction","text":"<p>Submit a transaction to the mempool.</p> <pre><code>const transaction = await new Transaction({\n    signer: keypair.public_key,\n    // nonce, commands, ... \n})\n.toSignedTx(keypair);\n\nconst response = await client.submit_transaction(\n    new SubmitTransactionRequest({ transaction })\n);\n</code></pre> <p>Note</p> <p>Types such as <code>Keypair</code> and <code>SubmitTransactionRequest</code> can be imported by the package <code>pchain-types-js</code>. E.g. <pre><code>const { Keypair, SubmitTransactionRequest } = require(\"pchain-types-js\");\n</code></pre></p> <p>In case you need free tokens for submitting transactions to Testnet, check out the Faucet Service for details.</p> <p>Request</p> <pre><code>class SubmitTransactionRequest {\n    transaction: Transaction,\n}\n</code></pre> <p>Response</p> <pre><code>class SubmitTransactionResponse {\n    error: Option&lt;SubmitTransactionError&gt;,\n}\n</code></pre> <p>Where <code>SubmitTransactionError</code>: <pre><code>enum SubmitTransactionError {\n    UnacceptableNonce = 0,\n    MempoolFull = 1,\n    Other = 2\n}\n</code></pre></p>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#transaction","title":"transaction","text":"<p>Get a transaction and optionally its receipt.</p> <pre><code>const response = await client.transaction(\n    new TransactionRequest({ transaction_hash, include_receipt })\n);\n</code></pre> <p>Request</p> <pre><code>class TransactionRequest {    \n    transaction_hash: Sha256Hash;\n    include_receipt: boolean;\n}\n</code></pre> <p>Response</p> <pre><code>class TransactionResponse {\n    transaction: Option&lt;Transaction&gt;;\n    receipt: Option&lt;Receipt&gt;;\n    block_hash: Option&lt;Sha256Hash&gt;;\n    position: Option&lt;u32&gt;;\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#transaction_position","title":"transaction_position","text":"<p>Find out where a transaction is in the blockchain.</p> <pre><code>const response = await client.transaction_position(\n    new TransactionPositionRequest({ transaction_hash })\n);\n</code></pre> <p>Request</p> <pre><code>class TransactionPositionRequest {\n    transaction_hash: Sha256Hash,\n}\n</code></pre> <p>Response</p> <pre><code>class TransactionPositionResponse {\n    transaction_hash: Option&lt;Sha256Hash&gt;;\n    block: Option&lt;Sha256Hash&gt;;\n    position: Option&lt;u32&gt;;\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#receipt","title":"receipt","text":"<p>Get a transaction's receipt.</p> <pre><code>const response = await client.receipt(\n    new ReceiptRequest({ transaction_hash })\n);\n</code></pre> <p>Request</p> <pre><code>class ReceiptRequest {    \n    transaction_hash: Sha256Hash;\n}\n</code></pre> <p>Response</p> <pre><code>class ReceiptResponse {\n    transaction_hash: Sha256Hash;\n    receipt: Option&lt;Receipt&gt;;\n    block_hash: Option&lt;Sha256Hash&gt;;\n    position: Option&lt;u32&gt;;\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#block-related-rpcs","title":"Block Related RPCs","text":"","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#block","title":"block","text":"<p>Get a block by its block hash.</p> <pre><code>const response = await client.block(\n    new BlockRequest({ block_hash })\n);\n</code></pre> <p>Request</p> <pre><code>class BlockRequest {\n    block_hash: Sha256Hash;\n}\n</code></pre> <p>Response</p> <pre><code>struct BlockResponse {\n    block: Option&lt;Block&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#block_header","title":"block_header","text":"<p>Get a block header by its block hash.</p> <pre><code>const response = await client.block_header(\n    new BlockHeaderRequest({ block_hash })\n);\n</code></pre> <p>Request</p> <pre><code>class BlockHeaderRequest {\n    block_hash: Sha256Hash;\n}\n</code></pre> <p>Response</p> <pre><code>class BlockHeaderResponse {\n    block_header: Option&lt;BlockHeader&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#block_height_by_hash","title":"block_height_by_hash","text":"<p>Get the height of the block with a given block hash. </p> <pre><code>const response = await client.block_height_by_hash(\n    new BlockHeightByHashRequest({ block_hash })\n);\n</code></pre> <p>Request</p> <pre><code>class BlockHeightByHashRequest {\n    block_hash: Sha256Hash;\n}\n</code></pre> <p>Response</p> <pre><code>class BlockHeightByHashResponse {\n    block_hash: Sha256Hash;\n    block_height: Option&lt;u64&gt;;\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#block_hash_by_height","title":"block_hash_by_height","text":"<p>Get the hash of a block at a given height.</p> <pre><code>const response = await client.block_hash_by_height(\n    new BlockHashByHeightRequest({ block_height })\n);\n</code></pre> <p>Request</p> <pre><code>class BlockHashByHeightRequest {\n    block_height: u64;\n}\n</code></pre> <p>Response</p> <pre><code>class BlockHashByHeightResponse {\n    block_height: u64;\n    block_hash: Option&lt;Sha256Hash&gt;;\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#highest_committed_block","title":"highest_committed_block","text":"<p>Get the hash of the highest committed block. </p> <pre><code>const response = await client.highest_committed_block();\n</code></pre> <p>Request</p> <p>None.</p> <p>Response</p> <pre><code>class HighestCommittedBlockResponse {\n    block_hash: Option&lt;Sha256Hash&gt;;\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#state-related-rpcs","title":"State Related RPCs","text":"<p>State RPCs return multiple entities in the world state in a single response. This allows clients to get a consistent snapshot of the world state in a single call.</p> <p>Every response structure includes the hash of the highest committed block when the snapshot is taken.</p> <p>Some of the following RPCs' response structures reference types unique to this document. These are specified in types referenced in state RPC responses.</p>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#state","title":"state","text":"<p>Get the state of a set of accounts (optionally including their contract code), and/or a set of storage tuples.</p> <pre><code>const response = await client.state(\n    new StateRequest({ accounts, include_contract, storage_keys })\n);\n</code></pre> <p>Request</p> <pre><code>class StateRequest {\n    accounts: Set&lt;PublicAddress&gt;;\n    include_contract: boolean;\n    storage_keys: Map&lt;PublicAddress, Set&lt;Uint8Array&gt;&gt;;\n}\n</code></pre> <p>Response</p> <pre><code>class StateResponse {\n    accounts: Map&lt;PublicAddress, Account&gt;;\n    storage_tuples: Map&lt;PublicAddress, Map&lt;Uint8Array, Uint8Array&gt;&gt;;\n    block_hash: Sha256Hash;\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#validator_sets","title":"validator_sets","text":"<p>Get the previous, current, and next validator sets, optionally including the stakes delegated to them.  </p> <pre><code>const response = await client.validator_sets(\n    new ValidatorSetsRequest({\n        include_prev,\n        include_prev_delegators,\n        include_curr,\n        include_curr_delegators,\n        include_next,\n        include_next_delegators\n    })\n);\n</code></pre> <p>Request</p> <pre><code>class ValidatorSetsRequest {\n    include_prev: boolean;\n    include_prev_delegators: boolean;\n    include_curr: boolean;\n    include_curr_delegators: boolean;\n    include_next: boolean;\n    include_next_delegators: boolean;\n}\n</code></pre> <p>Response</p> <pre><code>class ValidatorSetsResponse {\n    // The inner Option is None if we are at Epoch 0.\n    prev_validator_set: Option&lt;Option&lt;ValidatorSet&gt;&gt;;\n    curr_validator_set: Option&lt;ValidatorSet&gt;;\n    next_validator_set: Option&lt;ValidatorSet&gt;;\n    block_hash: Sha256Hash;\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#pools","title":"pools","text":"<p>Get a set of pools.</p> <pre><code>const response = await client.pools(\n    new PoolsRequest({ operators, include_stakes })\n);\n</code></pre> <p>Request</p> <pre><code>class PoolsRequest {\n    operators: Set&lt;PublicAddress&gt;;\n    include_stakes: boolean;\n}\n</code></pre> <p>Response</p> <pre><code>class PoolsResponse {\n    pools: Map&lt;PublicAddress, Option&lt;Pool&gt;&gt;;\n    block_hash: Sha256Hash;\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#deposits","title":"deposits","text":"<p>Get a set of deposits.</p> <pre><code>const response = await client.deposits(\n    new DepositsRequest({ stakes })\n);\n</code></pre> <p>Request</p> <pre><code>class DepositsRequest {\n    stakes: Set&lt;[PublicAddress, PublicAddress]&gt;;\n}\n</code></pre> <p>Response</p> <pre><code>class DepositsResponse {\n    deposits: Map&lt;[PublicAddress, PublicAddress], Option&lt;Deposit&gt;&gt;;\n    block_hash: Sha256Hash;\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#stakes","title":"stakes","text":"<p>Get a set of stakes.</p> <pre><code>const response = await client.stakes(\n    new StakesRequest({ stakes })\n);\n</code></pre> <p>Request</p> <pre><code>class StakesRequest {\n    stakes: Set&lt;[PublicAddress, PublicAddress]&gt;;\n}\n</code></pre> <p>Response</p> <pre><code>class StakesResponse {\n    stakes: Map&lt;[PublicAddress, PublicAddress], Option&lt;Stake&gt;&gt;;\n    block_hash: Sha256Hash;\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#view","title":"view","text":"<p>Call a method in a contract in a read-only way.</p> <pre><code>const response = await client.view(\n    new ViewRequest({ target, method, args })\n);\n</code></pre> <p>Request</p> <pre><code>class ViewRequest {\n    target: PublicAddress;\n    method: Uint8Array;\n    args: Option&lt;Uint8Array[]&gt;;\n}\n</code></pre> <p>Response</p> <pre><code>class ViewResponse {\n    receipt: CommandReceipt;\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#types-referenced-in-state-rpc-responses","title":"Types Referenced in State RPC Responses","text":"","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#account-related-types","title":"Account-related types","text":"<pre><code>class Account extends Enum {\n  accountWithContract?: AccountWithContract;\n  accountWithoutContract?: AccountWithoutContract;\n}\n\nclass AccountWithContract {\n    nonce: u64;\n    balance: u64;\n    contract: Option&lt;Uint8Array&gt;;\n    cbi_version: Option&lt;u32&gt;;\n    storage_hash: Option&lt;Sha256Hash&gt;;\n}\n\nclass AccountWithoutContract {\n    nonce: u64;\n    balance: u64;\n    cbi_version: Option&lt;u32&gt;;\n    storage_hash: Option&lt;Sha256Hash&gt;;\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/javascript_apis/#staking-related-types","title":"Staking-related types","text":"<pre><code>class ValidatorSet extends Enum {\n    poolsWithDelegator?: PoolWithDelegator[];\n    poolsWithoutDelegator?: PoolWithoutDelegator[];\n}\n\nclass PoolWithDelegators {\n    operator: PublicAddress;\n    power: u64;\n    commission_rate: number;\n    operator_stake: Option&lt;Stake&gt;;\n    delegated_stakes: Stake[];\n}\n\nclass PoolWithoutDelegators {\n    operator: PublicAddress;\n    power: u64;\n    commission_rate: number;\n    operator_stake: Option&lt;Stake&gt;;\n}\n\nclass Deposit {\n    owner: PublicAddress;\n    balance: u64;\n    auto_stake_rewards: boolean;\n}\n\nclass Stake {\n    owner: PublicAddress;\n    power: u64;\n}\n\nclass Pool extends Enum {\n    poolWithDelegator?: PoolWithDelegator;\n    poolWithoutDelegator?: PoolWithoutDelegator;\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Javascript","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/","title":"Rust Client APIs","text":"<p>ParallelChain RPC APIs are the HTTP APIs that Fullnodes make available to clients. </p> <p>In the section ParallelChain Client Library, we introduce the Rust Library to make RPC calls programatically. </p> <p>The Client Library allows you to easily submit RPC requests and parse RPC responses without the need to understand the details of HTTP URL, request format or response format. The formation of HTTP APIs is specified in ParallelChain Protocol.</p>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#parallelchain-client-library-rust","title":"ParallelChain Client Library (Rust)","text":"<p>ParallelChain Client Library is a Rust programming language implementation of ParallelChain RPC API. We will show how to use the library by example code. To use the library in your rust project, first add dependency pchain-client in <code>Cargo.toml</code> file. You will also need the dependency pchain-types for necessary basic types, and the dependency tokio to run the client in asynchronous application.</p> <p>Cargo.toml: <pre><code>[dependencies]\npchain-client = \"0.4.3\"\npchain-types = \"0.4.3\"\ntokio = {version = \"1\", features = [\"full\"]}\n</code></pre></p> <p>You can instantiate the struct <code>pchain_client::Client</code> by providing the link to a ParallelChain RPC endpoint.</p> <pre><code>#[tokio::main]\nasync fn main() {\n    /// Connect to Testnet RPC endpoint\n    let client = Client::new(\"https://pchain-test-rpc02.parallelchain.io\");\n    /// ...\n}\n</code></pre> <p>Note</p> <p>RPC endpoints for Mainnet and Testnet are <code>https://pchain-main-rpc02.parallelchain.io</code> and <code>https://pchain-test-rpc02.parallelchain.io</code> respectively.</p>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#transaction-related-rpcs","title":"Transaction Related RPCs","text":"","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#submit_transaction","title":"submit_transaction","text":"<p>Submit a transaction to the mempool.</p> <pre><code>// The function submit_transaction creates SubmitTransactionRequest from the input transaction.\nlet response: SubmitTransactionResponse = client\n    .submit_transaction(&amp;Transaction::new(\n        &amp;signer,\n        nonce,\n        vec![Command::Transfer(TransferInput {\n            amount,\n            recipient,\n        })],\n        gas_limit,\n        max_base_fee_per_gas,\n        priority_fee_per_gas,\n    ))\n    .await\n    .unwrap();\n</code></pre> <p>Note</p> <p>The variable <code>signer</code> is the Keypair of the EOA as the signer of the transaction. Check out the module pchain_types::cryptograhy for generating or importing keypair.</p> <p>In case you need free tokens for submitting transactions to Testnet, check out the Faucet Service for details.</p> <p>Request</p> <pre><code>struct SubmitTransactionRequest {\n    transaction: Transaction,\n}\n</code></pre> <p>Response</p> <pre><code>struct SubmitTransactionResponse {\n    error: Option&lt;SubmitTransactionError&gt;,\n}\n</code></pre> <p>Where <code>SubmitTransactionError</code>: <pre><code>enum SubmitTransactionError {\n    UnacceptableNonce,\n    MempoolFull,\n    Other,\n}\n</code></pre></p>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#transaction","title":"transaction","text":"<p>Get a transaction and optionally its receipt.</p> <pre><code>let response: TransactionResponse = client\n    .transaction(&amp;TransactionRequest {\n        transaction_hash,\n        include_receipt,\n    })\n    .await\n    .unwrap();\n</code></pre> <p>Request</p> <pre><code>struct TransactionRequest {    \n    transaction_hash: CryptoHash,\n    include_receipt: bool,\n}\n</code></pre> <p>Response</p> <pre><code>struct TransactionResponse {\n    transaction: Option&lt;Transaction&gt;,\n    receipt: Option&lt;Receipt&gt;,\n    block_hash: Option&lt;CryptoHash&gt;,\n    position: Option&lt;u32&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#transaction_position","title":"transaction_position","text":"<p>Find out where a transaction is in the blockchain.</p> <pre><code>let response: TransactionPositionResponse = client\n    .transaction_position(&amp;TransactionPositionRequest { transaction_hash })\n    .await\n    .unwrap();\n</code></pre> <p>Request</p> <pre><code>struct TransactionPositionRequest {\n    transaction_hash: CryptoHash,\n}\n</code></pre> <p>Response</p> <pre><code>struct TransactionPositionResponse {\n    transaction_hash: Option&lt;CryptoHash&gt;,\n    block_hash: Option&lt;CryptoHash&gt;,\n    position: Option&lt;u32&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#receipt","title":"receipt","text":"<p>Get a transaction's receipt.</p> <pre><code>let response: ReceiptResponse = client\n    .receipt(&amp;ReceiptRequest { transaction_hash })\n    .await\n    .unwrap();\n</code></pre> <p>Request</p> <pre><code>struct ReceiptRequest {    \n    transaction_hash: CryptoHash,\n}\n</code></pre> <p>Response</p> <pre><code>struct ReceiptResponse {\n    transaction_hash: CryptoHash,\n    receipt: Option&lt;Receipt&gt;,\n    block_hash: Option&lt;CryptoHash&gt;,\n    position: Option&lt;u32&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#block-related-rpcs","title":"Block Related RPCs","text":"","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#block","title":"block","text":"<p>Get a block by its block hash.</p> <pre><code>let response: BlockResponse = client\n    .block(&amp;BlockRequest { block_hash })\n    .await\n    .unwrap();\n</code></pre> <p>Request</p> <pre><code>struct BlockRequest {\n    block_hash: CryptoHash,\n}\n</code></pre> <p>Response</p> <pre><code>struct BlockResponse {\n    block: Option&lt;Block&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#block_header","title":"block_header","text":"<p>Get a block header by its block hash.</p> <pre><code>let response: BlockHeaderResponse = client\n    .block_header(&amp;BlockHeaderRequest { block_hash })\n    .await\n    .unwrap();\n</code></pre> <p>Request</p> <pre><code>struct BlockHeaderRequest {\n    block_hash: CryptoHash,\n}\n</code></pre> <p>Response</p> <pre><code>struct BlockHeaderResponse {\n    block_header: Option&lt;BlockHeader&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#block_height_by_hash","title":"block_height_by_hash","text":"<p>Get the height of the block with a given block hash. </p> <pre><code>let response: BlockHeightByHashResponse = client\n    .block_height_by_hash(&amp;BlockHeightByHashRequest { block_hash })\n    .await\n    .unwrap();\n</code></pre> <p>Request</p> <pre><code>struct BlockHeightByHashRequest {\n    block_hash: CryptoHash,\n}\n</code></pre> <p>Response</p> <pre><code>struct BlockHeightByHashResponse {\n    block_hash: CryptoHash,\n    block_height: Option&lt;BlockHeight&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#block_hash_by_height","title":"block_hash_by_height","text":"<p>Get the hash of a block at a given height.</p> <pre><code>let response: BlockHashByHeightResponse = client\n    .block_hash_by_height(&amp;BlockHashByHeightRequest { block_height })\n    .await\n    .unwrap();\n</code></pre> <p>Request</p> <pre><code>struct BlockHashByHeightRequest {\n    block_height: BlockHeight,\n}\n</code></pre> <p>Response</p> <pre><code>struct BlockHashByHeightResponse {\n    block_height: BlockHeight,\n    block_hash: Option&lt;CryptoHash&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#highest_committed_block","title":"highest_committed_block","text":"<p>Get the hash of the highest committed block. </p> <pre><code>let response: HighestCommittedBlockResponse = client\n    .highest_committed_block()\n    .await\n    .unwrap();\n</code></pre> <p>Request</p> <p>None.</p> <p>Response</p> <pre><code>struct HighestCommittedBlockResponse {\n    block_hash: Option&lt;CryptoHash&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#state-related-rpcs","title":"State Related RPCs","text":"<p>State RPCs return multiple entities in the world state in a single response. This allows clients to get a consistent snapshot of the world state in a single call.</p> <p>Every response structure includes the hash of the highest committed block when the snapshot is taken.</p> <p>Some of the following RPCs' response structures reference types unique to this document. These are specified in types referenced in state RPC responses.</p>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#state","title":"state","text":"<p>Get the state of a set of accounts (optionally including their contract code), and/or a set of storage tuples.</p> <pre><code>let response: StateResponse = client\n    .state(&amp;StateRequest {\n        accounts,\n        include_contract,\n        storage_keys,\n    })\n    .await\n    .unwrap();\n</code></pre> <p>Request</p> <pre><code>struct StateRequest {\n    accounts: HashSet&lt;PublicAddress&gt;,\n    include_contracts: bool,\n    storage_keys: HashMap&lt;PublicAddress, HashSet&lt;Vec&lt;u8&gt;&gt;&gt;,\n}\n</code></pre> <p>Response</p> <pre><code>struct StateResponse {\n    accounts: HashMap&lt;PublicAddress, Account&gt;,\n    storage_tuples: HashMap&lt;PublicAddress, HashMap&lt;Vec&lt;u8&gt;, Vec&lt;u8&gt;&gt;&gt;,\n    block_hash: CryptoHash,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#validator_sets","title":"validator_sets","text":"<p>Get the previous, current, and next validator sets, optionally including the stakes delegated to them.  </p> <pre><code> let response: ValidatorSetsResponse = client\n    .validator_sets(&amp;ValidatorSetsRequest {\n        include_prev,\n        include_prev_delegators,\n        include_curr,\n        include_curr_delegators,\n        include_next,\n        include_next_delegators,\n    })\n    .await\n    .unwrap();\n</code></pre> <p>Request</p> <pre><code>struct ValidatorSetsRequest {\n    include_prev: bool,\n    include_prev_delegators: bool,\n    include_curr: bool,\n    include_curr_delegators: bool,\n    include_next: bool,\n    include_next_delegators: bool,\n}\n</code></pre> <p>Response</p> <pre><code>struct ValidatorSetsResponse {\n    // The inner Option is None if we are at Epoch 0.\n    prev_validator_set: Option&lt;Option&lt;ValidatorSet&gt;&gt;,\n    curr_validator_set: Option&lt;ValidatorSet&gt;,\n    next_validator_set: Option&lt;ValidatorSet&gt;,\n    block_hash: CryptoHash,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#pools","title":"pools","text":"<p>Get a set of pools.</p> <pre><code>let response = client\n    .pools(&amp;PoolsRequest {\n        include_stakes,\n        operators,\n    })\n    .await\n    .unwrap();\n</code></pre> <p>Request</p> <pre><code>struct PoolsRequest {\n    operators: HashSet&lt;Operator&gt;,\n    include_stakes: bool,\n}\n</code></pre> <p>Response</p> <pre><code>struct PoolsResponse {\n    pools: HashMap&lt;Operator, Option&lt;Pool&gt;&gt;,\n    block_hash: CryptoHash,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#deposits","title":"deposits","text":"<p>Get a set of deposits.</p> <pre><code>let response: DepositsResponse = client\n    .deposits(&amp;DepositsRequest { stakes })\n    .await\n    .unwrap();\n</code></pre> <p>Request</p> <pre><code>struct DepositsRequest {\n    stakes: HashSet&lt;(Operator, Owner)&gt;,\n}\n</code></pre> <p>Response</p> <pre><code>struct DepositsResponse {\n    deposits: HashMap&lt;(Operator, Owner), Option&lt;Deposit&gt;&gt;,\n    block_hash: CryptoHash,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#stakes","title":"stakes","text":"<p>Get a set of stakes.</p> <pre><code>let response: StakesResponse = client\n    .stakes(&amp;StakesRequest { stakes })\n    .await\n    .unwrap();\n</code></pre> <p>Request</p> <pre><code>struct StakesRequest {\n    stakes: HashSet&lt;(Operator, Owner)&gt;,\n}\n</code></pre> <p>Response</p> <pre><code>struct StakesResponse {\n    stakes: HashMap&lt;(Operator, Owner), Option&lt;Stake&gt;&gt;,\n    block_hash: CryptoHash,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#view","title":"view","text":"<p>Call a method in a contract in a read-only way.</p> <pre><code>let response: ViewResponse = client\n    .view(&amp;ViewRequest {\n        target,\n        method,\n        arguments,\n    })\n    .await\n    .unwrap();\n</code></pre> <p>Request</p> <pre><code>struct ViewRequest {\n    target: PublicAddress,\n    method: Vec&lt;u8&gt;,\n    arguments: Option&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;,\n}\n</code></pre> <p>Response</p> <pre><code>struct ViewResponse {\n    receipt: CommandReceipt,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#types-referenced-in-state-rpc-responses","title":"Types Referenced in State RPC Responses","text":"","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#account-related-types","title":"Account-related types","text":"<pre><code>enum Account {\n    WithContract(AccountWithContract),\n    WithoutContract(AccountWithoutContract),\n}\n\nstruct AccountWithContract {\n    nonce: Nonce,\n    balance: Balance,\n    contract: Option&lt;Vec&lt;u8&gt;&gt;, \n    cbi_version: Option&lt;CBIVersion&gt;,\n    storage_hash: Option&lt;CryptoHash&gt;,\n}\n\nstruct AccountWithoutContract {\n    nonce: Nonce,\n    balance: Balance,\n    cbi_version: Option&lt;CBIVersion&gt;,\n    storage_hash: Option&lt;CryptoHash&gt;,\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/parallelchain_client_apis/rust_client_apis/#staking-related-types","title":"Staking-related types","text":"<pre><code>enum ValidatorSet {\n    WithDelegators(Vec&lt;PoolWithDelegators&gt;),\n    WithoutDelegators(Vec&lt;PoolWithoutDelegators&gt;),\n}\n\ntype Operator = PublicAddress;\ntype Owner = PublicAddress;\n\nstruct PoolWithDelegators {\n    operator: PublicAddress,\n    power: Balance,\n    commission_rate: u8, \n    operator_stake: Option&lt;Stake&gt;,\n    delegated_stakes: Vec&lt;Stake&gt;,\n}\n\nstruct PoolWithoutDelegators {\n    operator: PublicAddress,\n    power: Balance,\n    commission_rate: u8, \n    operator_stake: Stake,\n}\n\nstruct Deposit {\n    owner: PublicAddress,\n    balance: u64,\n    auto_stake_rewards: bool,\n}\n\nstruct Stake {\n    owner: PublicAddress,\n    power: Balance,\n}\n\nenum Pool {\n    WithStakes(PoolWithStakes),\n    WithoutStakes(PoolWithoutStakes),\n}\n</code></pre>","tags":["Tools","ParallelChain RPC API","Rust","Client"]},{"location":"for_developers/smart_contracts/getting_started/","title":"Getting Started","text":"<p>Before we dive deep into the structure of a contract and the SDK's semantics, we require some background information about the semantics enforced by ParallelChain Mainnet. The full capabilities of ParallelChain Mainnet continue to grow with active developers  and a growing community. Let's see how smart contracts are called and processed by a node in the form of transactions.</p> <p>First, the ParallelChain Client (<code>pchain_client</code>) will submit a transaction when making a smart contract call to the validating node using a serialization crate pchain-types. The node's RPC service and mempool will process the list of transactions and check for validity and correctness. </p> <p>Transactions that fail the validation check may not be included in a block. The transactions are then packed in a block and sent to the execution engine in the node to execute the transactions. </p> <p>The executor will call wasmer (Web Assembly Engine) which provides an isolated context to perform the execution. This enables the smart contract code to read the current state of the blockchain and interact with it. However, the execution results are temporarily stored and subject to further checks before the block may be committed or rolled back on error. </p> <p><code>wasmer</code> also computes the gas fees through a metering module, which is responsible for limiting the execution to the amount of gas paid. Each transaction returns a result in the form of receipts along with logs. The receipts (with or without log), transactions and block itself will contain its hash (or Merkle proof) and will be all included in the same block.</p>","tags":["pchain-sdk","Smart Contract"]},{"location":"for_developers/smart_contracts/getting_started/#smart-contract-development-kit","title":"Smart Contract Development Kit","text":"<p>Smart Contract can be created by using ParallelChain SDK. Example contracts can be found in example-smart-contracts.</p> <p>A ParallelChain Smart Contract is a rust crate that imports the SDK. It uses the SDK's features to interact with the blockchain. The folder structure of a typical ParallelChain Mainnet Smart Contract looks like this: <pre><code>my_first_contract\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 lib.rs # The main source code of your smart contract.  \n\u2514\u2500\u2500 Cargo.toml # You import your packages and the SDK here\n</code></pre></p> <p>For more information on Rust's crate system, see Rust Book Chapter 7: Packages and Crates</p> <p>Please specify the dependency in <code>Cargo.toml</code> for using SDK by fetching from crates.io or repository in Github.</p> Crates.ioGithub <pre><code>[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\npchain-sdk = \"0.4\"\n</code></pre> <pre><code>[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\npchain-sdk = { git = \"https://github.com/parallelchain-io/pchain-sdk\" }\n</code></pre>","tags":["pchain-sdk","Smart Contract"]},{"location":"for_developers/smart_contracts/getting_started/#implement-smart-contract","title":"Implement Smart Contract","text":"<p>Let's start with a sample smart contract for illustration in this guide. The smart contract code is written in the file <code>lib.rs</code>.</p> <pre><code>use pchain_sdk::{call, contract, contract_methods};\n\n#[contract]\nstruct MyContract { }\n\n#[contract_methods]\nimpl MyContract {\n\n    #[call]\n    fn hello_from(name :String) -&gt; u32 {\n        pchain_sdk::log(\n            \"topic: Hello From\".as_bytes(), \n            format!(\"Hello, Contract. From: {}\", name).as_bytes()\n        );\n        name.len() as u32\n    }\n}\n</code></pre> <p>The details about the macros (e.g. <code>contract</code>, <code>contract_methods</code>, <code>call</code>) used in the code can be found in later sections Contract Methods and Contract Storage. Let's skip knowing them first, and continue reading about building and deploying the contract in following sections.</p>","tags":["pchain-sdk","Smart Contract"]},{"location":"for_developers/smart_contracts/getting_started/#building-the-contract-with-pchain_compile","title":"Building The Contract With <code>pchain_compile</code>","text":"<p>pchain_compile is a CLI build tool for smart contract developers to build their source code to WASM binaries for deployment on  ParallelChain Mainnet. </p> <p>The WASM binary generated from a generic cargo build process has the following disadvantages: </p> <ul> <li> <p>The build process is not toolchain version agnostic i.e. it does not guarantee uniform WASM binaries with different versions of compiler and      rust crate dependencies. This will make it difficult for smart contract developers to verify their source code on the blockchain.</p> </li> <li> <p>The build process generates a large file size, which leads to higher gas costs for deployment and contract calls.</p> </li> </ul> <p>pchain_compile solves these shortcomings by: </p> <ul> <li> <p>Executing the build process in a docker environment with pre-defined toolchain versioning.</p> </li> <li> <p>Optimizing and compressing the size of the WASM binary with the help of wasm-snip and wasm-opt packages.</p> </li> </ul>","tags":["pchain-sdk","Smart Contract"]},{"location":"for_developers/smart_contracts/getting_started/#download-pchain_compile","title":"Download pchain_compile","text":"<p><code>pchain_compile</code> supports Linux, macOS and Windows. Depending on the operating system, they can be downloaded from Assets of ParallelChain Lab's Git Hub release page.</p> <p>The binary can also be installed and built by executing the following commands: <pre><code>cargo install pchain_compile\n</code></pre></p> <p>Pre-requisites</p> <p><code>pchain_compile</code> builds the source code in a docker environment. To know more about Docker and install it, refer to the official instructions.</p>","tags":["pchain-sdk","Smart Contract"]},{"location":"for_developers/smart_contracts/getting_started/#build-wasm-binary","title":"Build WASM Binary","text":"<p>In order to build a <code>WASM</code> binary of the smart contract, run the following command:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_compile build --source &lt;PATH_TO_SMART_CONTRACT_CODE&gt;\n</code></pre> <pre><code>./pchain_compile.exe build --source &lt;PATH_TO_SMART_CONTRACT_CODE&gt;\n</code></pre> <p>If you installed <code>pchain_compile</code> with <code>cargo install</code>, you can simply run:</p> <pre><code>pchain_compile build --source &lt;PATH_TO_SMART_CONTRACT_CODE&gt;\n</code></pre> <p>A <code>.wasm</code> file will be generated in the current directory.</p>","tags":["pchain-sdk","Smart Contract"]},{"location":"for_developers/smart_contracts/getting_started/#deploying-a-smart-contract","title":"Deploying a Smart Contract","text":"<p>You can deploy the contract using the pchain_client command line tool. You should make sure to know your latest account nonce before submitting the transaction.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n--nonce &lt;NONCE&gt; \\\n--gas-limit &lt;GAS_LIMIT&gt; \\\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; \\\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; \\\ndeploy \\\n--contract-code &lt;WASM_BINARY_PATH&gt; \\\n--cbi-version &lt;CBI_VERSION&gt; \n</code></pre> <pre><code>./pchain_client.exe transaction create `\n--nonce &lt;NONCE&gt; `\n--gas-limit &lt;GAS_LIMIT&gt; `\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; `\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; `\ndeploy `\n--contract-code &lt;WASM_BINARY_PATH&gt; `\n--cbi-version &lt;CBI_VERSION&gt; \n</code></pre> <p>You can refer to the instruction and example arguments in Create &amp; Submit Transaction to create and submit a transaction through <code>pchain-client</code>.</p>","tags":["pchain-sdk","Smart Contract"]},{"location":"for_developers/smart_contracts/getting_started/#checking-contract-in-state","title":"Checking Contract In State","text":"<p>To verify that the smart contract is deployed correctly, you can run the command <code>query</code> with the flag <code>contract</code>. It queries the state of the blockchain and saves the wasm code as <code>code.wasm</code> in the current directory. If you want to store the contract file in your preferred location, you need to provide the flag <code>destination</code> to specify the path with your preferred file extension:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query contract --address &lt;CONTRACT_ADDRESS&gt;\n</code></pre> <pre><code>./pchain_client.exe query contract --address &lt;CONTRACT_ADDRESS&gt;\n</code></pre>","tags":["pchain-sdk","Smart Contract"]},{"location":"for_developers/smart_contracts/getting_started/#calling-contract","title":"Calling Contract","text":"<p>Suppose you have already deployed a contract that contains a <code>call</code> method named <code>hello_from</code> as mentioned in previous section Implement Smart Contract:</p> <pre><code>#[call]\nfn hello_from(name :String) -&gt; u32\n</code></pre> <p>To invoke this contract by using <code>pchain_client</code>, you can prepare a JSON file that contains a list of arguments and matches with the <code>call</code> method. For example, this <code>call</code> method takes a string argument. Then, the content of the JSON file should be as follows:</p> <pre><code>{\n    \"arguments\": [\n        {\"argument_type\":\"String\", \"argument_value\": \"\\\"Alice\\\"\"}\n    ]\n}\n</code></pre> <p>This JSON file will be used in creating a transaction with Call Command.</p>","tags":["pchain-sdk","Smart Contract"]},{"location":"for_developers/smart_contracts/getting_started/#submit-transaction-with-call-command","title":"Submit Transaction With Call Command","text":"<p>To call a smart contract, submit a transaction with your account nonce and contract address using the <code>pchain_client</code>.</p> <p>Here is the command to call a contract:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n--nonce &lt;NONCE&gt; \\\n--gas-limit &lt;GAS_LIMIT&gt; \\\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; \\\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; \\\ncall \\\n--target &lt;CONTRACT_ADDRESS&gt; \\\n--method &lt;contract_METHOD&gt; \\\n--arguments &lt;CALL_ARGUMENT_FILE_PATH_WITH_FILE_NAME&gt;\n--amount &lt;AMOUNT_TO_CONTRACT&gt; \\\n</code></pre> <pre><code>./pchain_client.exe transaction create `\n--nonce &lt;NONCE&gt; `\n--gas-limit &lt;GAS_LIMIT&gt; `\n--max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; `\n--priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; `\ncall `\n--target &lt;CONTRACT_ADDRESS&gt; `\n--method &lt;contract_METHOD&gt; `\n--arguments &lt;CALL_ARGUMENT_FILE_PATH_WITH_FILE_NAME&gt; `\n--amount &lt;AMOUNT_TO_CONTRACT&gt;\n</code></pre> <p>The command argument <code>method</code> is the name of the method with macro <code>#[call]</code> in the code. Take the contract in Implement Smart Contract as example, \"hello_from\" should be set as the value of the command argument <code>method</code>.</p> <p>The command argument <code>arguments</code> is the JSON file that contains the method arguments to the method being called in the contract. The way to create this JSON file is described in previous section Calling Contract.</p> <p>The gas limit required for the transaction depends on the complexity of the smart contract. For safety reasons, you can always set a higher gas limit. You can also test contract calls on testnet to reassure.</p> <p>You can refer to the instruction and example arguments in Create &amp; Submit Transaction to create and submit a transaction through <code>pchain-client</code>.</p> <p>To query the resulting receipt of the transaction, </p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query tx --hash &lt;TRANSACTION_HASH&gt; \n</code></pre> <pre><code>./pchain_client.exe query tx --hash &lt;TRANSACTION_HASH&gt;\n</code></pre> <p>The commands stored in <code>transaction</code> and command receipts in <code>receipt</code> are following the same order. That means you can always find the corresponding transaction from a command receipt.</p>","tags":["pchain-sdk","Smart Contract"]},{"location":"for_developers/smart_contracts/getting_started/#parse-call-result","title":"Parse Call Result","text":"<p>To parse the response from the contract method, represented in the field named <code>return value</code> , which is in <code>CallResult</code> format, you can use the <code>parse call-result</code> command in ParallelChain Client.</p> <p>For example, if the contract method returns a u32 integer, the <code>return value</code> is \"BQAAAA\" you can parse the <code>CallResult</code> data structure using the <code>--data-type u32</code> flag:</p> Linux / macOSWindows PowerShell <pre><code>pchain_client parse call-result --value BQAAAA --data-type u32\n</code></pre> <pre><code>./pchain_client.exe parse call-result --value BQAAAA --data-type u32\n</code></pre> <p>The output will be the parsed value of the <code>CallResult</code>, which in this case is <code>5</code>. For more details, you can use the <code>help</code> command to see the usage of the tool or take a look at the example <code>argument,json</code>.</p>","tags":["pchain-sdk","Smart Contract"]},{"location":"for_developers/smart_contracts/installing_sdk/","title":"Installing SDK","text":"","tags":["pchain-sdk","Smart Contract","Rust"]},{"location":"for_developers/smart_contracts/installing_sdk/#installing-rust","title":"Installing Rust","text":"<p>To install the required toolkits, the standard method is by <code>rustup</code>, which maintains dependencies and is a version manager for <code>cargo</code> and <code>rustc</code> (the rust compiler). Detailed installation instructions can be found on the official website.</p>","tags":["pchain-sdk","Smart Contract","Rust"]},{"location":"for_developers/smart_contracts/installing_sdk/#setting-up-a-development-environment","title":"Setting up a Development Environment","text":"<p>A recommended Integrated Development Environment (IDE) is VSCode, which allows the addition of the plugin rust-analyzer to type-check all of your code on save. This feature allows you to locate errors in the code easily, and the error messages displayed in the IDE are the same as when executing the <code>cargo build</code> command. However, any other editor that is comfortable for you can be used. However, any other editor that is comfortable for you can be used.</p>","tags":["pchain-sdk","Smart Contract","Rust"]},{"location":"for_developers/smart_contracts/installing_sdk/#installing-wasm-toolchain-optional","title":"Installing Wasm Toolchain (Optional)","text":"<p>ParallelChain Mainnet also provides a smart contract compilation tool called pchain-compile to compile your Rust smart contract into WASM bytecode. While not necessary, the Installation of Wasm Toolchain can help check if your code is compilable before using the time-consuming process in the use of <code>pchain-compile</code>.</p> <p>The <code>wasm32-unknown-unknown</code> toolchain is required for smart contracts to compile as WASM. To add the wasm toolchain in Rust, type the command below: <pre><code>rustup target add wasm32-unknown-unknown\n</code></pre></p> <p>To build your smart contract as WASM bytecode, use the command below: <pre><code>cargo build --target wasm32-unknown-unknown\n</code></pre></p>","tags":["pchain-sdk","Smart Contract","Rust"]},{"location":"for_developers/smart_contracts/introduction/","title":"Introduction to Smart Contracts","text":"<p>A smart contract presents a method of executing computer programs on a decentralized network with security and fault tolerance. Through smart contracts, users can develop code to support their most crucial business applications, all within a global, decentralized network.</p> <p>To use smart contracts on ParallelChain Mainnet, developers can write a Contract Binary Interface (CBI) Subprotocol that is implemented in WebAssembly (WASM). However, for most developers, it's easier to use the ParallelChain Mainnet Contract SDK (<code>pchain-sdk</code>) to write a Contract in Rust, and subsequently use a tool named pchain-compile to compile the Rust source code into WASM bytecode.</p>","tags":["pchain-sdk","Smart Contract"]},{"location":"for_developers/smart_contracts/introduction/#smart-contract-programming-model","title":"Smart Contract Programming Model","text":"<p>The Smart Contract Programming Model follows Object-Oriented Programming (OOP) principles. In this model, a contract resembles a Rust <code>struct</code> that regulates access to persistent storage. Accounts can engage with contracts by submitting transactions containing a call command to invoke the contract's methods. These methods are commonly referred to as just \"methods\".</p>","tags":["pchain-sdk","Smart Contract"]},{"location":"for_developers/smart_contracts/introduction/#why-rust-and-webassembly-wasm","title":"Why Rust and WebAssembly (WASM)?","text":"<p>Writing smart contracts in Rust and executing them as WebAssembly (WASM) bytecode on a blockchain has several benefits:</p> <ol> <li> <p>Efficiency and Security: Rust is a systems programming language that provides a balance between performance and safety. It is designed to prevent common programming errors such as null pointer dereferencing and buffer overflows, which can cause security vulnerabilities. Rust's ownership model and borrow checker also help prevent memory leaks and race conditions. When compiled to WASM, Rust code can run efficiently and securely on a blockchain.</p> </li> <li> <p>Interoperability: WASM is a binary format that can be executed in different environments, such as web browsers and servers. This means that smart contracts written in programming languages and compiled to WASM can be executed on the blockchain that supports the WASM execution context. This provides more options for developers to choose from and promotes interoperability between different blockchain ecosystems.</p> </li> <li> <p>Tooling and Ecosystem: Rust has a rich ecosystem of libraries and tools for building systems and applications. This includes the mentioned <code>pchain-sdk</code>, which provides types and macros for writing smart contracts in Rust for the ParallelChain Mainnet blockchain. Rust's cargo package manager also makes it easy to manage dependencies and build projects. By leveraging the Rust ecosystem, developers can build smart contracts faster and with less effort.</p> </li> <li> <p>Community Support: Rust has a growing community of developers and contributors who are passionate about the language and its ecosystem. This means that there are resources available for learning Rust and getting help when needed. It also means that the language and ecosystem are constantly evolving and improving.</p> </li> </ol>","tags":["pchain-sdk","Smart Contract"]},{"location":"for_developers/smart_contracts/introduction/#parallelchain-mainnet-contract-sdk","title":"ParallelChain Mainnet Contract SDK","text":"<p>The ParallelChain Mainnet Contract SDK (pchain-sdk) is an open-source Rust crate designed to aid in smart contract development. It furnishes Rust structs, functions, types, and macros to facilitate the creation of smart contracts executable in WebAssembly (WASM) engines, implementing the ParallelChain Mainnet Contract Binary Interface (CBI) Subprotocol.</p> <p>This documentation caters to both novice and advanced users, aiming to guide them toward successfully creating their first smart contract in ParallelChain.</p> <p>For sharing smart contract code, addresses, or any assistance with smart contract creation, please visit GitHub Discussions.</p> <p>For issues related to the SDK or smart contracts, please visit GitHub issues.</p>","tags":["pchain-sdk","Smart Contract"]},{"location":"for_developers/smart_contracts/preparing_env/","title":"Preparing Environment","text":"<p>You have the the tools to develop smart contracts. You also need the environment to deploy and call your smart contracts. You can utilize the Mainnet as a production environment for your business application, as well as the Testnet as a testing environment before deploying your release to Mainnet.</p>","tags":["mainnet","testnet","explorer"]},{"location":"for_developers/smart_contracts/preparing_env/#checking-the-network","title":"Checking the Network","text":"<p>You can check the Mainnet by viewing the ParallelChain Explorer:</p> <ul> <li>ParallelChain Mainnet Explorer </li> </ul> <p>The explorer can explore transactions, addresses, information about the network, and blocks.</p> <p>To verify that Testnet is alive:</p> <ul> <li>https://pchain-test-rpc02.parallelchain.io</li> </ul> <p>You can use ParallelChain Client CLI (called <code>pchain_client</code>) to interact with the <code>Testnet</code> node.</p>","tags":["mainnet","testnet","explorer"]},{"location":"for_developers/smart_contracts/preparing_env/#setting-up-parallelchain-client-cli","title":"Setting Up ParallelChain Client CLI","text":"<p>Before we start developing the smart contracts, the <code>pchain_client</code> executable needs to be configured.</p> <p>If you are not yet familiar with <code>pchain_client</code>, See Install and Setup to install <code>pchain_client</code> and learn about the basic functionalities before proceeding with smart contract development.</p>","tags":["mainnet","testnet","explorer"]},{"location":"for_developers/smart_contracts/prfc/","title":"ParallelChain Request for Comments (PRFC)","text":"<p>PRFC (ParallelChain Request for Comments) defines application layer standards which specifies common interface of ParallelChain Smart Contract and its state representation so that applications running on ParallelChain can interact with for a well-defined purpose.</p> <p>The number suffix is identified as each standard\u2019s unique ID. For example, PRFC1 defines a standard interface for fungible tokens, and PRFC2 for non-fungible tokens (similar meanings as ERC20 and ERC721 in Ethereum).</p> <p>You can find all PRFCs in this GitHub repository prfcs. Please feel free to leave your comments or submit proposals on the Issues page.</p>","tags":["PRFC","Smart Contract","Token Standard"]},{"location":"for_developers/smart_contracts/advanced/accessing_info_about_blockchain/","title":"Accessing Information about the Blockchain","text":"<p>Contract Methods can be written to not only depend on call arguments and the contract's storage, but also on information about the Blockchain, e.g., the previous block hash, or the identity of the External Account that originated the Transaction with Call Command.</p> <p>Functions for getting information about the Transaction that triggered a Contract call and information about the larger Blockchain in general are defined in <code>pchain_sdk::transaction</code> and <code>pchain_sdk::blockchain</code> respectively. Internally, these functions are thin wrappers around functions defined in the Imports Set of the CBI.</p>","tags":["pchain-sdk","Smart Contract","transaction"]},{"location":"for_developers/smart_contracts/advanced/accessing_info_about_blockchain/#parameters-from-blockchain-and-transaction","title":"Parameters from Blockchain and Transaction","text":"<p>Contract execution is triggered by a Call Transaction to the blockchain. The contract being executed can obtain information from this transaction, and also the blockchain during execution. The information can be obtained by calling API methods in <code>pchain_sdk</code>.</p> <p>Example: <pre><code>// Get the timestamp of this block\nlet timestamp = pchain_sdk::blockchain::timestamp();\n</code></pre></p> <p>Related APIs in <code>pchain_sdk::blockchain</code>:</p> <pre><code>/// Get the `block_number` field of the Block that contains the Transaction which triggered this Contract call. \nfn block_number() -&gt; Vec&lt;u8&gt;;\n/// Get the `prev_block_hash` field of the Block that contains the Transaction which triggered this Contract call.\nfn prev_block_hash() -&gt; Vec&lt;u8&gt;;\n/// Get the `timestamp` field of the Block that contains the Transaction which triggered this Contract call.\nfn timestamp() -&gt; u32;\n/// Get the `balance` of the current account.\nfn balance() -&gt; u53;\n</code></pre> <p>Related APIs in <code>pchain_sdk::transaction</code>:</p> <pre><code>/// Get from the address of invoking the transaction\nfn calling_account() -&gt; [u8;32];\n/// Get to the address of invoking the transaction\nfn current_address() -&gt; [u8;32];\n/// Get the value of invoking transaction\nfn amount() -&gt; u64;\n/// Returns whether it is an internal call\nfn is_internal_call() -&gt; bool;\n/// Get transaction hash of invoking transaction\nfn transaction_hash() -&gt; [u8;32];\n/// Get the method name of the invoking Contract Method\nfn method() -&gt; String;\n/// Get method arguments of the invoking Contract Method\nfn arguments() -&gt; Vec&lt;u8&gt;;\n</code></pre>","tags":["pchain-sdk","Smart Contract","transaction"]},{"location":"for_developers/smart_contracts/advanced/contract_methods/","title":"Contract Methods","text":"<p>In ParallelChain Smart Contract Programming Model, a contract is like a <code>Rust</code> <code>struct</code> that controls access to persistent storage. Accounts can interact with contracts by submitting transactions that include a call command to invoke methods of the contract. These methods are sometimes called just \"methods\" for short.</p>","tags":["pchain-sdk","Smart Contract","Contract Methods"]},{"location":"for_developers/smart_contracts/advanced/contract_methods/#contract-methods","title":"Contract Methods","text":"<p>The Model defines methods with macro <code>#[call]</code> as Contract Methods, each corresponding to a method that is callable to a Call Command in the CBI Subprotocol.</p> <p>In order to produce to appropriate CBI Exports Set bindings that ultimately allow Methods to be called from the outside world, you must write Method definitions inside an <code>impl Contract</code> statement marked with the <code>#[contract_methods]</code> macro, as illustrated in the following examples.</p> <pre><code>#[contract_methods]\nimpl PrinceTheDog {\n    #[call]\n    pub fn eat_food(&amp;mut self, food: DogFood) {\n        ...\n    }\n}\n</code></pre> <p>Methods may mutate Contract Storage. Note however, that (as specified in the Transaction Subprotocol) mutations to Contract Storage made in a Call Transaction only get applied if the Transaction is Successful (e.g., the Transaction must exit with sufficient gas, must have not panicked during execution, etc.).</p> <p>A function can be called if and only if:</p> <ol> <li>The macro #[call] is added above the function declaration.</li> <li>Its (zero or more) other arguments implement BorshDeserialize.</li> <li>Its return value implements BorshSerialize, or it does not have a return value.</li> </ol>","tags":["pchain-sdk","Smart Contract","Contract Methods"]},{"location":"for_developers/smart_contracts/advanced/contract_methods/#accepting-parameters-and-returning-values","title":"Accepting Parameters and Returning Values","text":"<p>Some of the code snippets provided as examples in this document depict Contract Methods that take in function arguments (besides a borrow of the Contract struct) and/or return a value. In order for a Contract to receive arguments from and return values to the 'outside world' (callers), both Contract and caller need to agree on a serialization format.</p> <p><code>pchain-sdk</code> expects callers to serialize Method arguments using the borsh serialization standard, and generates code to serialize values into borsh for inclusion in a Transaction's Receipt. To be precise, Transaction Command Call specify the Contract Method to call and provide the arguments for the call by including a borsh-serialized data structure <code>Option&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;</code> in its <code>arguments</code> field, and contracts include a borsh-serialized <code>ContractMethodOutput</code> struct. The former type is defined in <code>pchain-types</code>, while the latter is defined in <code>pchain-sdk</code>. In the future, we plan to move both into the SDK.</p>","tags":["pchain-sdk","Smart Contract","Contract Methods"]},{"location":"for_developers/smart_contracts/advanced/contract_storage/","title":"Contract Storage","text":"<p>Contracts can use Storage to persist data between calls. The simplest way to read and write data into Storage is to add fields to the Contract struct:</p> <pre><code>#[contract]\nstruct PrinceTheDog {\n    age: u8, \n    breed: String,\n    hungry: bool,\n    toy: DogToy,\n}\n</code></pre> <p>The <code>#[contract]</code> macro transparently generates code that loads all of a Contract struct's fields from Storage before the execution of the contract method and saves those fields into Contract Storage after the contract method returns. All types that implement the <code>Storage</code> trait can be used as a Contract field. Out of the box, this includes all Rust primitive types, as well as other commonly used types like <code>Option&lt;T&gt;</code>, <code>Result&lt;T&gt;</code>, <code>Vec&lt;T&gt;</code>, etc. In addition, structs defined by the developer can be made to implement <code>Storage</code> by applying the <code>#[contract_field]</code> macro on their definitions, provided that all of their fields implement Storage:</p> <pre><code>#[contract_field]\nstruct DogToy {\n    ...\n}\n</code></pre>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"for_developers/smart_contracts/advanced/contract_storage/#accessing-storage","title":"Accessing Storage","text":"<p>SDK provides functions to access Storage by read-write operations. The function <code>get_network_state</code> is particularly used to get the state from the Network Account of the blockchain.</p> <p>Related APIs in <code>pchain_sdk::storage</code>:</p> <pre><code>/// Gets the value, if any, associated with the provided key in this Contract Storage.\npub fn get(key: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt;;\n/// Gets the value, if any, associated with the provided key in Network Account's Storage.\npub fn get_network_state(key: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt;;\n/// Binds the provided key to the provided value in this Contract's Storage.\npub fn set(key: &amp;[u8], value: &amp;[u8]);\n</code></pre>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"for_developers/smart_contracts/advanced/contract_storage/#storage-and-collections","title":"Storage and Collections","text":"<p>Because Storage is so gas-expensive, loading all of a Contract's fields before Method execution and writing them all into Storage after execution typically results in Contracts that are not very economical. For Contracts that do not keep much in Storage, or whose Methods always read and write into most fields, this may be okay, or even ideal, however, some applications cannot avoid keeping a lot of on-chain states, and for these applications eagerly loading and saving fields in every call may be unacceptably expensive.</p> <p>To solve this, the SDK includes a <code>pchain_sdk::collections</code> module. All of the types defined in this module 'lazily' load Storage: they only incur a read or write gas cost when the exact item in the collection is read from or written to. They also offer an API that can make working with large collections of data more convenient.</p> <pre><code>#[contract]\nstruct PrinceTheDog {\n    nicknames: Vector&lt;String&gt;\n}\n</code></pre>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"for_developers/smart_contracts/advanced/contract_storage/#cacher-cachert","title":"Cacher (<code>Cacher&lt;T&gt;</code>)","text":"<p>Wraps over any non-collections type that implements <code>Storage</code> and makes them lazy (all <code>collections</code> types are already lazy without Cacher). Cacher implements <code>Deref</code>, so <code>Cacher&lt;T&gt;</code> can be used almost everywhere <code>T</code> can be used without any special syntax. </p> <p>In the example below, the contract field <code>lazy_cat</code> is a <code>Cacher</code> of <code>String</code>. Passing the immutable receiver <code>&amp;self</code> to the method does not immediately load its data from the world state until dereferencing the field <code>lazy_cat</code>. In the method<code>set_cat_name</code>, the calling function <code>set</code> does not immediately save its data to the world state until the end of this method call.</p> <pre><code>#[contract]\nstruct Pet {\n    lazy_cat: Cacher&lt;String&gt;\n}\n\n#[contract_methods]\nimpl Pet { \n\n    //...\n\n    #[call]\n    fn cat_name(&amp;self) -&gt; String {\n        self.lazy_cat.to_uppercase()\n    }\n\n    #[call]\n    fn set_cat_name(&amp;mut self, name: String) {\n        self.lazy_cat.set(name);\n    }\n\n    // ...\n}\n</code></pre>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"for_developers/smart_contracts/advanced/contract_storage/#vector-vectort","title":"Vector (<code>Vector&lt;T&gt;</code>)","text":"<p>Lazily stores a list of items in <code>Storage</code>. Vector implements <code>Index</code>, <code>IndexMut</code>, and has an <code>iter</code> method, so most of the things you can do with <code>std::vec::Vec</code>, you can probably do with <code>Vector</code> too.</p> <p>In the below example, the contract field <code>nicknames</code> is a <code>Vector</code> of <code>String</code>. It loads data from the world state only when it is needed to be read, and stores data after the method call. It calls <code>iter()</code> to get an iterator as <code>std::vec::Vec</code>, and calls <code>push()</code> to save data to the world state. Besides, it supports indexing for accessing particular indexed elements.</p> <pre><code>#[contract]\nstruct Me {\n    nicknames: Vector&lt;String&gt;\n}\n\n#[contract_methods]\nimpl Me { \n\n    // ...\n\n    #[call]\n    fn my_name_is(&amp;self, name: String) -&gt; bool {\n        self.nicknames.iter().any(|n| n == &amp;name)\n    }\n\n    #[call]\n    fn call_me(&amp;mut self, name: String) {\n        self.nicknames.push(&amp;name);\n    }\n\n    // ...\n}\n</code></pre>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"for_developers/smart_contracts/advanced/contract_storage/#maps-fastmapk-v-and-iterablemapk-v","title":"Maps (<code>FastMap&lt;K, V&gt;</code> and <code>IterableMap&lt;K, V&gt;</code>)","text":"<p>Collections include two types that store statically typed mapping between keys and values. The difference between these two types is that IterableMap is, as its name suggests, iterable. i.e., it has the standard library's HashMap's <code>keys</code>, <code>iter</code>, and <code>values</code> sets of methods. This functionality comes at the cost of storing slightly more data in Storage than FastMap. Both types function identically otherwise, down to being able to nest like-Maps together (e.g., <code>FastMap&lt;T, FastMap&lt;K, V&gt;&gt;</code>, but not <code>FastMap&lt;T, IterableMap&lt;K, V&gt;&gt;</code>).</p> <p>You should use IterableMap if your application needs to iterate through stored items, otherwise, use FastMap.</p>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"for_developers/smart_contracts/advanced/contract_storage/#example-fastmapk-v","title":"Example - FastMap&lt;K, V&gt;","text":"<pre><code>type Address = [u8; 32];\n\n#[contract]\nstruct NameResolution {\n    name_mapping: FastMap&lt;Address, String&gt;\n}\n\n#[contract_methods]\nimpl NameResolution { \n\n    // ...\n\n    #[call]\n    fn resolve(&amp;self, address: Address) -&gt; Option&lt;String&gt; {\n        self.name_mapping.get(&amp;address)\n    }\n\n    #[call]\n    fn add_record(&amp;mut self, address: Address, name: String) {\n        self.name_mapping.insert(&amp;address, name)\n    }\n\n    // ...\n}\n</code></pre>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"for_developers/smart_contracts/advanced/contract_storage/#example-iterablemapk-v","title":"Example - IterableMap&lt;K, V&gt;","text":"<pre><code>#[contract]\nstruct Market {\n    prices: IterableMap&lt;String, u32&gt;\n}\n\n#[contract_methods]\nimpl Market {\n\n    // ...\n\n    #[call]\n    fn price(&amp;self, item: String) -&gt; Option&lt;u32&gt; {\n        self.prices.get(&amp;item)\n    }\n\n    #[call]\n    fn set_price(&amp;mut self, item: String, price: u32) {\n        self.prices.insert(&amp;item, price);\n    }\n\n    #[call]\n    fn total_price(&amp;self) -&gt; u32 {\n        self.prices.values().sum()\n    }\n\n    // ...\n}\n</code></pre>","tags":["pchain-sdk","Smart Contract","World State"]},{"location":"for_developers/smart_contracts/advanced/cross_contract_call/","title":"Cross Contract Call","text":"<p>The SDK includes a pair of functions to make Contract-To-Contract internal calls:</p> <ul> <li><code>call</code> and <code>call_untyped</code></li> </ul> <p>It does the obvious: to call a method in a specified Contract with the given arguments.</p> <p>Related APIs in <code>pchain_sdk::internal</code>:</p> <pre><code>/// A call to contract. The caller should already know the data type of return value from the function call.\n/// It returns Option of T where T is return value from the function. \n/// If data type T is different from the actual return value type of the function, None is returned.\nfn call&lt;T: borsh::BorshDeserialize&gt;(address: PublicAddress, method_name: &amp;str, arguments: Vec&lt;u8&gt;, value: u64) -&gt; Option&lt;T&gt;;\n\n/// A call to contract, with vector of bytes as return type.\n/// It returns Option of Vec of bytes. Interpretation on the bytes depends on caller\nfn call_untyped(contract_address: PublicAddress, method_name: &amp;str, arguments: Vec&lt;u8&gt;, value: u64) -&gt; Option&lt;Vec&lt;u8&gt;&gt;;\n</code></pre>","tags":["pchain-sdk","Smart Contract","Cross Contract Call"]},{"location":"for_developers/smart_contracts/advanced/cryptographic_functions/","title":"Cryptographic Functions","text":"<p>Cryptographic Function refers to cryptographic functions that are supported from execution runtime so that gas cost can be reduced by avoiding implementation inside a contract. Moreover, It helps in providing complicated calculations which are not feasible in the Wasmer environment (e.g. encryption, hashing).</p> <p>Please be noted that some functions are selected based on the popularity of the blockchain ecosystem, but are not necessary adopted in the implementation of the ParallelChain Mainnet node.</p> Function Description Gas Cost sha256 SHA256 hash function 16 x length of the input keccak256 Keccak-256 hash function 16 x length of the input ripemd RIPEMD-160 hash function 16 x length of the input verify_ed25519_signature Verification on ed25519 signature 1,400,000 + 16 x length of the input <p>The gas consumption is estimated by the compute costs for precompile functions used by developers to deploy smart contracts on ParallelChain Mainnet.</p> <p>Related APIs in <code>pchain_sdk::crypto</code>:</p> <pre><code>/// Computes the SHA256 digest (32 bytes) of arbitrary input.\nfn sha256(input: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt;;\n/// Computes the Keccak256 digest (32 bytes) of arbitrary input.\nfn keccak256(input: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt;;\n/// Computes the RIPEMD160 digest (20 bytes) of arbitrary input.\nfn ripemd(input: Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt;;\n/// Returns whether an Ed25519 signature was produced by a specified by a specified address over some specified message.\n/// Contract call fails if the input `address` or `signature` is not valid.\nfn verify_ed25519_signature(input: Vec&lt;u8&gt;, signature: Vec&lt;u8&gt;, address: Vec&lt;u8&gt;) -&gt; bool;\n</code></pre>","tags":["pchain-sdk","Smart Contract","Cryptographic Functions"]},{"location":"for_developers/smart_contracts/advanced/staking_in_contract/","title":"Staking in Contract","text":"<p>Contract address can be used as owner in staking, in other words, to perform staking on behalf of a contract. It is done by invoking a contract call to create staking command(s) (i.e. Create Deposit, TopupDeposit, ... etc) inside the contract method. The execution of these staking commands will be deferred after the successful execution of the entire contract call. To create deferred staking command, you can call functions <code>defer_*</code> provided by the SDK.</p> <p>Notes</p> <ul> <li>The owner of the staking is using a contract address.</li> <li>There is no additional command receipt. Failure of deferred staking command execution results in failure of the entire contract call. </li> <li>The <code>return values</code> in the final receipt will be overwritten (if any) by the staking command.</li> <li>In the cross-contract-call scenario, deferred staking command is not executed after the internal contract call, but after the origin contract call.</li> </ul> <p>Related APIs in <code>pchain_sdk::network</code>:</p> <pre><code>/// Instantiation of a Deposit in the state.\nfn defer_create_deposit(operator: PublicAddress, balance: u64, auto_stake_rewards: bool);\n/// Update settings of an existing Deposit.\nfn defer_set_deposit_settings(operator: PublicAddress, auto_stake_rewards: bool);\n/// Increase the balance of an existing Deposit.\nfn defer_topup_deposit(operator: PublicAddress, amount: u64);\n/// Withdraw balance from an existing Deposit.\nfn defer_withdraw_deposit(operator: PublicAddress, max_amount: u64);\n/// Increase stakes to an existing Pool\nfn defer_stake_deposit(operator: PublicAddress, max_amount: u64);\n/// Remove stakes from an existing Pool.\nfn defer_unstake_deposit(operator: PublicAddress, max_amount: u64);\n</code></pre>","tags":["pchain-sdk","Smart Contract","Staking"]},{"location":"for_developers/smart_contracts/advanced/transferring_balance/","title":"Transferring Balance","text":"<p><code>pchain_sdk::transfer</code> transfers the balance from the Contract Account to another Account and returns the balance of the recipient after the transfer.</p> <p>Related API in <code>pchain_sdk::internal</code>:</p> <pre><code>/// Transfer the balance amount to another address. \nfn transfer(recipient: PublicAddress, amount: u64);\n</code></pre> <p>Notes</p> <ul> <li>Balance is deducted from the contract, but not the caller's account.</li> <li>Gas cost is deducted from the caller's account.</li> </ul> <p>Example:</p> <pre><code>/// Use method transfer() to send tokens from this contract balance to a specific address.\n#[call]\nfn send_tokens(value :u64){\n    let contract_address = Base64URL::decode(\"-jUt6jrEfMRD1JM9n6_yAASl2cwsc4tg1Bqp07gvQpU\").unwrap().try_into().unwrap();\n    pchain_sdk::transfer(\n        contract_address,\n        value\n    );\n}\n</code></pre>","tags":["mainnet","testnet 4","parallelchain sdk","smart contract","internal transaction"]},{"location":"for_developers/smart_contracts/smart_contract_examples/1_hello_contract/","title":"Example - Hello Contract","text":"<p>We will go through the steps of creating a simple smart contract with the help of <code>pchain-sdk</code>.</p> <p>Firstly, we have to prepare the <code>Cargo.toml</code>, which specifies the name, version, and year of edition of the smart contract. We need to use <code>pchain-sdk</code> for this smart contract development, so remember to add <code>pchain-sdk = { version = \"LATEST_VERSION\"}</code> under dependencies.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/1_hello_contract/#cargotoml","title":"Cargo.toml","text":"<pre><code>[package]\nname = \"hello_contract\"\nversion = \"0.4.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\npchain-sdk = { git = \"https://github.com/parallelchain-io/pchain-sdk.git\" }\n</code></pre> <p>After preparing <code>Cargo.toml</code>, we can now start preparing the smart contract.  </p> <p><code>#[contract]</code> defines basic struct as a programming model of a contract.  Fields are data representations of contract storage.</p> <p><code>#[contract_methods]</code> defines impl for the contract struct. </p> <p><code>#[call]</code> macro applies to impl methods for the contract method call. Methods declared under this macro are callable by Transaction Command - Call.</p> <p>In the file, we have added a method called <code>hello()</code>. In this method, the SDK provided function <code>pchain_sdk::log()</code> logs the information as a key-value pair and appends it to the Logs in a transaction receipt.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/1_hello_contract/#librs","title":"lib.rs","text":"<pre><code>use pchain_sdk::{\n    contract, contract_methods, call, storage, log, \n};\n\n#[contract]\nstruct HelloContract {}\n\n#[contract_methods] \nimpl HelloContract {\n\n    #[call]\n    fn hello() {\n        pchain_sdk::log(\n            \"topic: Hello\".as_bytes(), \n            \"Hello, Contract\".as_bytes()\n        );\n    }\n}\n</code></pre> <p>Next, we can add two other methods, which illustrate how we can set and get values from the storage by using the SDK provided functions in crate pchain_sdk::storage.</p> <pre><code>#[call]\nfn hello_set_many() {\n    for i in 1..10{\n        let key = format!(\"hello-key-{}\", i);\n        let value = vec![0_u8; 1024*10]; //10KB\n        storage::set(key.as_bytes(), &amp;value);\n    }\n}\n\n#[call]\nfn hello_read_many() {\n    for i in 1..10{\n        let key = format!(\"hello-key-{}\", i);\n        let value = storage::get(key.as_bytes());\n        if value.is_some(){\n            log(\n                \"topic: Hello read\".as_bytes(), \n                format!(\"key: {}, len: {}\", key, value.unwrap().len()).as_bytes()\n            );\n        }\n    }\n}\n</code></pre>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/2_my_little_pony/","title":"Example - My Little Pony","text":"<p>We will implement a smart contract called <code>MyLittlePony</code>, to demonstrate how a contract can:</p> <ul> <li>define entrypoint methods</li> <li>define fields as data in contract storage</li> </ul> <p>From the last chapter, we have learned that the macro <code>contract</code> on struct allows getting or setting data from or into the world state.  The key to be stored started with a zero-indexed u8 integer ordered by the fields in the contract struct.</p> <p>In this chapter, we first create a struct, <code>MyLittlePony</code>, that consists of <code>name</code>, <code>age</code>, and <code>gender</code>. In this case, <code>name</code> has key <code>[0]</code> while <code>age</code> has key <code>[1]</code>.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/2_my_little_pony/#librs-define-mylittlepony","title":"lib.rs: define MyLittlePony","text":"<pre><code>use pchain_sdk::{\n    contract, contract_methods, call, contract_field\n};\n\n#[contract]\npub struct MyLittlePony {\n    name: String,\n    age: u32,\n    gender: Gender,\n}\n</code></pre> <p>Next, we need to declare the <code>Gender</code> struct, which is the type of the <code>gender</code> field. To use the nested struct in the contract struct, we need the <code>contract_field</code> macro to define the key of its fields in canonical format. For instance, <code>gender</code> should have a key started with <code>[2]</code> in the contract <code>MyLittlePony</code>, so the <code>name</code> in <code>Gender</code> struct has a key <code>[2][0]</code>.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/2_my_little_pony/#librs-define-gender","title":"lib.rs: define Gender","text":"<pre><code>#[contract_field]\nstruct Gender {\n    name: String,\n    description: String\n}\n</code></pre> <p>After getting all the structs ready, we should start implementing the contract methods. This smart contract should provide three method calls:</p> <ul> <li>self_introduction()</li> <li>grow_up()</li> <li>change_pony()</li> </ul> <p>Firstly, <code>self_introduction()</code> uses receiver <code>&amp;self</code> to load all data before executing this method. All data will be loaded to the receiver self from the world state. In this way, we can obtain all the values of the fields in the contract, including the fields in the <code>Gender</code> struct.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/2_my_little_pony/#librs-load-data-with-self","title":"lib.rs: load data with &amp;self","text":"<pre><code>#[contract_methods]\nimpl MyLittlePony {\n\n    #[call]\n    fn self_introduction(&amp;self) -&gt; String {\n        format!(\"Hi, I am {}. Age of {}. I am {} that means {}.\",\n            self.name, self.age, self.gender.name, self.gender.description)\n    }\n}\n</code></pre> <p>In the next method, we are going to illustrate how we can use contract getter and setter to access the data in the world state. The advantage of this is that the Write gas cost is smaller compared to what we did in <code>self_introduction()</code> because only one key-value pair (i.e. <code>age</code>) is involved.</p> <p>Instead of passing <code>&amp;self</code> as an argument, simply do <code>Self::get_&lt;field_name&gt;()</code> to get the value and  <code>Self::set_&lt;field_name&gt;()</code> to set updated value.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/2_my_little_pony/#librs-getter-and-setter","title":"lib.rs: getter and setter","text":"<pre><code>#[call]\nfn grow_up() {\n    let age = Self::get_age();\n    Self::set_age(age+1)\n}\n</code></pre> <p>Lastly, we want to change our little pony, so we use a mutable receiver <code>&amp;mut self</code> to load data before executing this method, then store all data after execution. However, we should be cautious when using a mutable receiver as it is expensive to load and store since it mutates all key-value pairs (i.e. <code>name</code>, <code>age</code> and <code>gender</code>) in the world state.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/2_my_little_pony/#librs-load-data-with-a-mutable-receiver","title":"lib.rs: load data with a mutable receiver","text":"<pre><code>#[call]\nfn change_pony(&amp;mut self, name: String, age: u32, gender_name: String, description: String) {\n    pchain_sdk::log(\n        \"update_gender\".to_string().as_bytes(), \n        format!(\"update name:{} description: {}\", name, description).as_bytes());\n    self.name = name;\n    self.age = age;\n    self.gender.name = gender_name;\n    self.gender.description = description;\n}\n</code></pre> <p>Now you should have learned how to get and set contract fields in your smart contract.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/3_my_bank/","title":"Example - My Bank","text":"<p>We have introduced macros including <code>contract</code>, <code>contract methods</code>, and <code>call</code> in the contract Hello Contract and accessing values of fields from storage in the contract My Little Pony. Here we will put together all the knowledge and implement the bank smart contract that simulates banking operations with data stored in ParallelChain Mainnet.</p> <p>Before diving into the writing of a smart contract, let's define the data struct <code>BankAccount</code> which will be stored in the storage.</p> <p><code>bank_account.rs</code> defined the struct <code>BankAccount</code> which consists of four fields, <code>first_name</code>, <code>last_name</code>, <code>account_id</code>, and <code>amount</code>.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/3_my_bank/#bank_accountrs-define-data-struct","title":"bank_account.rs: define data struct","text":"<pre><code>use borsh::{BorshDeserialize, BorshSerialize};\n\nuse pchain_sdk::{\n    storage,\n};\n\n// Note that both the serializer and deserializer macros such as Borsh need to \n// be applied to this struct for it to work.\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct BankAccount {\n    pub first_name: String,\n    pub last_name: String,\n    pub account_id: String,\n    pub amount: u64,\n}\n</code></pre> <p>We are using BorshDeserialize and BorshSerialize in the above struct because we will serialize this struct into bytes and store them into the storage. Remember to update the Cargo.toml by adding the crate borsh. We need the crate base64 for encoding the corresponding Account ID too. Therefore, add the following two lines under the dependencies section in Cargo.toml:</p> <ul> <li>base64 = \"0.13\"</li> <li>borsh = \"=0.10.2\"</li> </ul> <p>Here we are not going to define the <code>BankAccount</code> data as a field in contract struct. But we will be able to load and save the data by using <code>storage::get</code> and <code>storage::set</code> explicitly. Let's add the following two methods for getting and setting the value with a given key. </p> <p><code>get_bank_account()</code> retrieves the value (i.e. <code>BankAccount</code>) of the given key from storage by using <code>pchain_sdk::storage::get()</code>.</p> <p><code>set_bank_account()</code> stores the value (i.e. <code>BankAccount</code>) of the given key to storage by using  <code>pchain_sdk::storage::set()</code>.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/3_my_bank/#bank_accountrs-accessing-storage","title":"bank_account.rs: accessing storage","text":"<pre><code>pub fn get_bank_account(key: &amp;[u8]) -&gt; Option&lt;BankAccount&gt; {\n    match storage::get(key) {\n        Some(raw_result) =&gt; {\n            let p: Option&lt;BankAccount&gt; =\n                match BorshDeserialize::deserialize(&amp;mut raw_result.as_ref()) {\n                    Ok(d) =&gt; Some(d),\n                    Err(_) =&gt; None,\n                };\n            p\n        }\n        None =&gt; None,\n    }\n}\n\npub fn set_bank_account(key: &amp;[u8], value: &amp;BankAccount) {\n    let mut buffer: Vec&lt;u8&gt; = Vec::new();\n    value.serialize(&amp;mut buffer).unwrap();\n    storage::set(key, buffer.as_ref());\n}\n</code></pre> <p>Lastly, add the impl of <code>BankAccount</code> which includes two methods that perform the actions of deposit and withdrawal.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/3_my_bank/#bank_accountrs-impl-methods","title":"bank_account.rs: impl methods","text":"<pre><code>impl BankAccount {\n    pub fn deposit_to_balance(&amp;mut self, amount_to_add: u64) {\n        self.amount += amount_to_add;\n    }\n    pub fn withdraw_from_balance(&amp;mut self, amount_to_withdraw: u64) -&gt; Option&lt;u64&gt; {\n        if amount_to_withdraw &lt;= self.amount {\n            self.amount -= amount_to_withdraw;\n            Some(self.amount)\n        } else {\n            None\n        }\n    }\n}\n</code></pre> <p>After having the <code>BankAccount</code> struct ready, it is time to start writing the bank smart contract. <code>use bank_account::BankAccount;</code> allows us to use the methods defined in <code>bank_account.rs</code>.</p> <p>The macro <code>contract</code> above struct defines the basic structure of the contract which has only one field, <code>num_of_account</code>, indicating the number of accounts associated with this bank. This field has a key <code>[0]</code>.</p> <p>Note</p> <p>The key to be stored started with a zero-indexed u8 integer ordered by the fields in the contract struct.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/3_my_bank/#librs-define-contract-struct","title":"lib.rs: define contract struct","text":"<pre><code>use pchain_sdk::{\n    contract, contract_methods, call, crypto\n};\n\nmod bank_account;\n\nuse bank_account::BankAccount;\n\n#[contract]\nstruct MyBank {\n    num_of_account: u64\n}\n</code></pre> <p>Remember that the macro <code>#[contract_methods]</code> generates entrypoint methods that can be called in transaction. We will create the first entrypoint method in <code>MyBank</code> impl. Firstly, we need the entrypoint method <code>open_account()</code> to create a brand-new account, with the specified <code>first_name</code>, <code>last_name</code>, <code>account_id</code>, and <code>initial_deposit</code>.</p> <p>In <code>open_account()</code>, we initialize an instance of <code>BankAccount</code>, and store it in the storage directly by invoking <code>bank_account::set_bank_account()</code> with its Account ID as a key.</p> <p>After storing the newly generated account into storage, we have to update the <code>num_of_account</code>. Therefore, we obtain the value of the field by doing <code>MyBank::get_num_of_account()</code>, like how we get the fields of our little pony in Chapter 2. Similarly, set the updated value by calling <code>MyBank::set_num_of_account()</code>.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/3_my_bank/#librs-open-a-new-account","title":"lib.rs: open a new account","text":"<pre><code>#[contract_methods]\nimpl MyBank {\n\n    /// entrypoint method \"open_account\"\n    #[call]\n    fn open_account(\n        first_name: String,\n        last_name: String,\n        account_id: String,\n        initial_deposit: u64,\n    ) {\n        let parsed_account_id= \n        if account_id != \"\" {\n            account_id.to_owned().as_bytes().to_vec()\n        } else {\n\n            // Generate a new account id using the base64 encoded sha256 hash\n            // of the first and last name concatenated together\n\n            let input = format!(\"{}{}\", &amp;first_name, &amp;last_name).to_string().as_bytes().to_vec();\n            crypto::sha256(input)\n        };\n\n        // Create a new instance of BankAccount\n        let opened_bank_account = BankAccount {\n            first_name: first_name.to_owned(),\n            last_name: last_name.to_owned(),\n            account_id:  base64::encode(parsed_account_id),\n            amount: initial_deposit,\n        };\n\n        // Calling the functions from bank_account.rs\n        bank_account::set_bank_account(\n            &amp;opened_bank_account.account_id.as_bytes(),\n            &amp;opened_bank_account\n        );\n\n        let initial_num_of_account = MyBank::get_num_of_account();\n        MyBank::set_num_of_account(initial_num_of_account + 1);\n\n        pchain_sdk::log(\n            \"bank_account: Open\".as_bytes(),\n            format!(\"Successfully opened \n            account for {}, {} \n            with account_id: {}\",\n            &amp;opened_bank_account.first_name,\n            &amp;opened_bank_account.last_name,\n            &amp;opened_bank_account.account_id).as_bytes()\n        );\n    }\n}\n</code></pre> <p>Now, we have successfully implemented an entrypoint method that creates a new bank account, we should support other basic banking functionalities.</p> <p>Let's start with checking account balance, users need to know how much money is left in their accounts.</p> <p>The method <code>bank_account::get_bank_account()</code> returns <code>Option&lt;BankAccount&gt;</code> by a given <code>account_id</code>. If  <code>None</code> is returned, the account does not exist; otherwise, we will be able to obtain the balance of the account by  accessing the field <code>amount</code>.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/3_my_bank/#librs-query-account-balance","title":"lib.rs: query account balance","text":"<pre><code>#[call]\nfn query_account_balance(account_id: String) {\n    match bank_account::get_bank_account(account_id.as_bytes()) {\n        Some(account) =&gt; {\n            pchain_sdk::log(\n                format!(\"bank: query_account_balance\").as_bytes(),\n                format!(\n                    \"The current balance is: {}\", \n                    &amp;account.amount\n                ).as_bytes()\n            );\n        },\n        None =&gt; {\n            pchain_sdk::log(\n                format!(\"bank: query_account_balance\").as_bytes(),\n                format!(\"No such account found\").as_bytes()\n            );\n        }\n    }\n}\n</code></pre> <p>Lastly, finish up the functionalities of the bank by completing the implementation of <code>withdraw_money()</code> and  <code>deposit_money()</code> using the methods mentioned in all previous sections.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/3_my_bank/#librs-withdrawal-and-deposit","title":"lib.rs: withdrawal and deposit","text":"<pre><code>#[call]\nfn withdraw_money(account_id: String, amount_to_withdraw: u64) {\n    match bank_account::get_bank_account(account_id.as_bytes()) {\n        Some(mut account) =&gt; {\n            match account.withdraw_from_balance(amount_to_withdraw) {\n                Some(balance) =&gt; {\n\n                    // update the world state\n                    bank_account::set_bank_account(account_id.as_bytes(), &amp;account);\n\n                    pchain_sdk::log(\n                        format!(\"bank: withdraw_money\").as_bytes(),\n                        format!(\"The updated balance is: \\n\n                        Name: {} {}\\n\n                        Account Number: {}\\n\n                        Balance: {}\", \n                        &amp;account.first_name,\n                        &amp;account.last_name,\n                        &amp;account.account_id,\n                        &amp;balance).as_bytes()\n                    );\n                }\n                None =&gt; pchain_sdk::log(\n                    format!(\"bank: withdraw_money\").as_bytes(),\n                    format!(\"You do not have enough funds to withdraw from this account.\").as_bytes()\n                ),\n            }\n        },\n        None =&gt; pchain_sdk::log(\n            format!(\"bank: withdraw_money\").as_bytes(),\n            format!(\"No such account found\").as_bytes()\n        ),\n    };\n}\n</code></pre> <pre><code>#[call]\nfn deposit_money(account_id: String, amount_to_deposit: u64) {\n    match bank_account::get_bank_account(account_id.as_bytes()) {\n        Some(mut account) =&gt; {\n            account.deposit_to_balance(amount_to_deposit);\n\n            // update the world state\n            bank_account::set_bank_account(account_id.as_bytes(), &amp;account);\n\n            pchain_sdk::log(\n                format!(\"bank: deposit_money\").as_bytes(),\n                format!(\"The updated balance is: \\nName: {} {}\\nAccount Number: {}\\nBalance: {}\", \n                &amp;account.first_name,\n                &amp;account.last_name,\n                &amp;account.account_id,\n                &amp;account.amount).as_bytes()\n            );\n        },\n        None =&gt; pchain_sdk::log(\n            format!(\"bank: query_account_balance\").as_bytes(),\n            format!(\"No such account found\").as_bytes()\n        ),\n    };\n}\n</code></pre>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/4_contract_proxy/","title":"Example - Contract Proxy","text":"<p>We will look at how the contract <code>ContractProxy</code> use the <code>use_contract</code> macro to interact with other contracts. In general, <code>ContractProxy</code> is a contract that serves as a middle-man to another contract My Little Pony. </p> <p>There are two kinds of interaction between the two contracts:</p> <ul> <li>calling another contract's entrypoint methods.</li> <li>sending tokens from the balance of one contract to another contract.</li> </ul> <p>To call another contract, firstly use the macro <code>use_contract</code> to specify the contract entrypoint methods in a trait. The address is hard-coded when using this macro. It is recommended to remove or comment out  the methods that are not intended to be used. </p> <p>Recall that we have a deployed contract called <code>MyLittlePony</code> that consists of three methods, <code>self_introduction()</code>, <code>grow_up()</code>, and <code>change_person()</code>. We are going to use <code>grow_up()</code> in  <code>ContractProxy</code>, so we can comment out the rest of them. </p> <p>Pre-requisites</p> <p>Deploy My Little Pony smart contract, and then replace the address supplied to <code>use_contract</code> macro with the smart contract address of My Little Pony.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/4_contract_proxy/#librs-define-a-trait","title":"lib.rs: define a trait","text":"<pre><code>use pchain_sdk::{\n    use_contract, call, contract, contract_methods\n};\n\n#[use_contract(\"xxT5OXMonFm8wcDw-io1jeyAEnxSddGPOG-ZezArCV4\")]\npub trait MyLittlePony {\n    //fn self_introduction() -&gt; String;\n    fn grow_up();\n    //fn change_person(name: String, age: u32, gender_name: String, description: String);\n}\n</code></pre> <p>The trait will be transformed to mod by using the macro <code>use_contract</code>, Calling the contract <code>MyLittlePony</code> can be simply calling the methods in the trait as associated functions. For example, one way of calling  <code>grow_up()</code> is to simply do <code>my_little_pony::grow_up(0)</code>.</p> <p>After defining the trait that specifies the other contract, we start implementing the functionalities of our contract <code>ContractProxy</code>.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/4_contract_proxy/#librs-use_contract-macro","title":"lib.rs: use_contract macro","text":"<pre><code>#[contract]\npub struct ContractProxy {}\n\n#[contract_methods]\nimpl ContractProxy {\n\n    #[call]\n    fn grow_up() {\n        my_little_pony::grow_up(0);\n    }\n}\n</code></pre> <p>The above example has shown how we can use the <code>use_contract</code> macro to do cross-contract calls. It is also possible to use <code>pchain_sdk::call_untyped()</code> to do so. We pass the contract address as an argument so that the contract address does not need to be hard-coded in the contract.</p> <p>Note</p> <p>Add <code>base64url = \"0.1.0\"</code> under <code>[Dependency]</code> in <code>Cargo.toml</code> for the project.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/4_contract_proxy/#librs-pchain_sdkcall_untyped","title":"lib.rs: pchain_sdk::call_untyped()","text":"<pre><code>#[call]\nfn grow_up_2(address: String) {\n    let contract_address = base64url::decode(&amp;address).unwrap().try_into().unwrap();\n    pchain_sdk::call_untyped(\n        contract_address,\n        \"grow_up\", \n        Vec::new(),\n        0\n    );\n}\n</code></pre>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/4_contract_proxy/#librs-transfer-contract-balance","title":"lib.rs: transfer contract balance","text":"<p>Except by calling the entrypoint methods from <code>MyLittlePony</code>, we can also transfer the balance from the  contract to a specific address by <code>pchain_sdk::transfer()</code> (see Transferring Balance).</p> <pre><code>#[call]\nfn send_tokens(to_address: String, value :u64){\n    let contract_address = base64url::decode(&amp;to_address).unwrap().try_into().unwrap();\n    pchain_sdk::transfer(\n        contract_address,\n        value\n    );\n}\n</code></pre>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/5_my_collections/","title":"Example - My Collections","text":"<p>We are going to demonstrate the use of module collections in <code>pchian-sdk</code>.</p> <p><code>collections</code> are designed as a data structure for gas efficiency:</p> <ul> <li>Cacher: allows lazy loading of a field in contract storage</li> <li>Vector: lazily stores a list of items</li> <li>FastMap: lazily stores items into a key-value map</li> <li>IterableMap: lazily stores items into an iterable key-value map</li> </ul> <p>We create the <code>MyCollections</code> struct which includes all these collection structures.</p>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/5_my_collections/#librs","title":"lib.rs","text":"<pre><code>use pchain_sdk::{\n    contract, contract_methods, call, Cacher, collections::{Vector, FastMap, IterableMap}\n};\n\ntype Address = [u8; 32];\n\n#[contract]\npub struct MyCollections {\n    lazy_cat: Cacher&lt;String&gt;,\n    pretty_numbers: Vector&lt;i32&gt;,\n    address_resolver: FastMap&lt;Address, String&gt;,\n    prices: IterableMap&lt;String, u32&gt;\n}\n</code></pre>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/5_my_collections/#cacher","title":"Cacher","text":"<p><code>Cacher</code> is a data wrapper to support Lazy Read and Lazy Write to a field in Contract Storage.</p> <pre><code>#[contract_methods]\nimpl MyCollections {\n\n    /// Here we use the receiver `&amp;self` without loading data before executing this method. \n    #[call]\n    fn meow(&amp;self) -&gt; String {\n        // Actual loading happens here. \n        // Dereference as immutable and invoke a function as &amp;String\n        self.lazy_cat.to_uppercase()\n    }\n\n    /// Here we use the receiver `&amp;mut self` without loading data before executing this method. \n    #[call]\n    fn feed(&amp;mut self, data: String) {\n        // Dereference as mutable and then assign a value to it\n        self.lazy_cat.set(data);\n        // Actual saving happens after this method\n    }\n}\n</code></pre>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/5_my_collections/#vector","title":"Vector","text":"<pre><code>/// Here we use the receiver `&amp;self` without loading data before executing this method. \n#[call]\nfn pick(&amp;self, index: usize) -&gt; Option&lt;i32&gt; {\n    // Actual loading happens here. \n    // Dereference as immutable and call functions from iterator\n    self.pretty_numbers.iter().nth(index).map(|value| *value)\n}\n\n/// Here we use the receiver `&amp;mut self` without loading data before executing this method. \n#[call]\nfn push(&amp;mut self, num: i32) -&gt; usize {\n    // Dereference as mutable and then set a value to it\n    self.pretty_numbers.push(&amp;num);\n    self.pretty_numbers.len()\n    // Actual saving happens after this method\n}\n</code></pre>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/5_my_collections/#fastmap","title":"FastMap","text":"<pre><code>/// Here we use the receiver `&amp;self` without loading data before executing this method. \n#[call]\nfn resolve(&amp;self, address: Address) -&gt; Option&lt;String&gt; {\n    // Actual loading happens here. \n    // Dereference as immutable and call functions from key-value map\n    self.address_resolver.get(&amp;address)\n}\n\n/// Here we use the receiver `&amp;mut self` without loading data before executing this method. \n#[call]\nfn add_record(&amp;mut self, address: Address, name: String) {\n    // Dereference as mutable and then insert a value\n    self.address_resolver.insert(&amp;address, name)\n    // Actual saving happens after this method\n}\n</code></pre>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/5_my_collections/#iterablemap","title":"IterableMap","text":"<pre><code>/// Here we use the receiver `&amp;self` without loading data before executing this method. \n#[call]\nfn price(&amp;self, item: String) -&gt; Option&lt;u32&gt; {\n    // Actual loading happens here. \n    // Dereference as immutable and call functions from key-value map\n    self.prices.get(&amp;item)\n}\n\n/// Here we use the receiver `&amp;mut self` without loading data before executing this method. \n#[call]\nfn set_price(&amp;mut self, item: String, price: u32) {\n    // Dereference as mutable and then insert a value\n    self.prices.insert(&amp;item, price);\n    // Actual saving happens after this method\n}\n\n/// This method the iterable-map to calculate the sum of the values by iterating each item.\n#[call]\nfn total_price(&amp;self) -&gt; u32 {\n    self.prices.values().sum()\n}\n</code></pre>","tags":["pchain-sdk","tutorial","Smart Contract"]},{"location":"for_developers/smart_contracts/smart_contract_examples/6_my_pool/","title":"Example - My Pool","text":"<p>We are going to study how to use staking commands in smart contracts. </p> <p>In ParallelChain Mainnet, there are six different staking commands:</p> <ul> <li>Create deposit</li> <li>Set deposit settings</li> <li>Top-up deposit</li> <li>Withdraw deposit</li> <li>Stake deposit</li> <li>Unstake deposit</li> </ul> <p>We will demonstrate how the above staking commands can be created within a smart contract  which acts as owner of the deposit/stakes (See Staking in Contract). We will use the contract, <code>MyPool</code>,  to guide you through the steps of creating a stake in a pool.</p>","tags":["pchain-sdk","tutorial","Smart Contract","Staking"]},{"location":"for_developers/smart_contracts/smart_contract_examples/6_my_pool/#librs-define-a-struct","title":"lib.rs: define a struct","text":"<p><pre><code>use pchain_sdk::{\n    call, contract, contract_methods\n};\n\ntype Address = [u8;32];\n\n#[contract]\npub struct MyPool {\n    pool_operator: Address,\n    my_friend: Address\n}\n</code></pre> We have created the struct <code>MyPool</code>, which consists of the addresses of the <code>pool_operator</code> and <code>my_friend</code>. These data will be all zeros by default. Therefore, we have to add an initialization function to set the addresses we want.</p>","tags":["pchain-sdk","tutorial","Smart Contract","Staking"]},{"location":"for_developers/smart_contracts/smart_contract_examples/6_my_pool/#librs-initialize-struct","title":"lib.rs: initialize struct","text":"<pre><code>#[contract_methods]\nimpl MyPool {\n\n    #[call]\n    fn init(pool_operator: Address, my_friend: Address){\n        MyPool { pool_operator, my_friend }.set();\n    } \n\n}\n</code></pre> <p>After adding the <code>init()</code> function, we can try creating a deposit into the pool. <code>pchain_sdk::network:defer_create_deposit()</code> allows us to deposit some XPLL into a specified pool. In this contract, we have already specified the pool in the field <code>pool_operator</code>.</p> <p>The staking commands are \"deferred\" because the actual execution of such commands occurs after the execution of a successful call. </p> <p>Note</p> <p>The deposit is created on behalf of the contract address, not from your account address, so make sure to transfer sufficient balance to the contract for the operation.</p> <p>To check if the deposit is successful, you can check the deposit using <code>pchain-client</code> with the following command: <pre><code>./pchain_client query deposit --operator &lt;OPERATOR_ADDRESS&gt; --owner &lt;CONTRACT_ADDRESS&gt;\n</code></pre></p>","tags":["pchain-sdk","tutorial","Smart Contract","Staking"]},{"location":"for_developers/smart_contracts/smart_contract_examples/6_my_pool/#librs-successful-staking-command","title":"lib.rs: successful staking command","text":"<pre><code>    #[call]\n    fn create_deposit(balance: u64, auto_stake_rewards: bool) {\n        pchain_sdk::network::defer_create_deposit(Self::get_pool_operator(), balance, auto_stake_rewards)\n    }\n</code></pre> <p>It was mentioned above that the <code>defer</code> call will only take place after a successful call. Here, we are making the transaction fail deliberately by transferring more than what we have in balance. As a result, the transaction call will fail, and the stake should not be deposited. </p> <p>Check the deposit again using <code>pchain-client</code>, the deposit balance in the pool should remain unchanged.</p>","tags":["pchain-sdk","tutorial","Smart Contract","Staking"]},{"location":"for_developers/smart_contracts/smart_contract_examples/6_my_pool/#librs-failed-staking-command","title":"lib.rs: failed staking command","text":"<pre><code>    #[call]\n    fn transfer_too_much() {\n        let balance = pchain_sdk::blockchain::balance();\n        pchain_sdk::transfer(Self::get_my_friend(), balance + 1);\n        pchain_sdk::network::defer_stake_deposit(Self::get_pool_operator(), balance);\n    }\n</code></pre> <p>Note</p> <p>The return values in the transaction receipt will be overwritten by the deferred staking commands. </p> <p>In the method <code>stake_deposit()</code>, we should be expecting that the <code>return_values</code> in the receipt will be the  balance of the contract (see ParallelChain Mainnet Protocol). However, since there is another deferred staking command in the method call, the <code>return_values</code> will be overwritten by the result of executing <code>pchain_sdk::network::defer_staking_deposit()</code> command.</p>","tags":["pchain-sdk","tutorial","Smart Contract","Staking"]},{"location":"for_developers/smart_contracts/smart_contract_examples/6_my_pool/#librs-overwriting-return-value","title":"lib.rs: overwriting return value","text":"<pre><code>    #[call]\n    fn stake_deposit(max_amount: u64) -&gt; u64{\n        pchain_sdk::network::defer_stake_deposit(Self::get_pool_operator(), max_amount);\n        pchain_sdk::blockchain::balance()\n    }\n</code></pre> <p>Lastly, we can include multiple deferred staking commands within one transaction. In this method <code>multiple_defer()</code>, we put the deferred staking commands for unstaking and withdrawing deposits together.</p> <p>Both the commands will be executed after the success of the transaction, and in the order they were called. After invoking this method call, the stake of the deposit should have been successfully unstaked and withdrawn.</p>","tags":["pchain-sdk","tutorial","Smart Contract","Staking"]},{"location":"for_developers/smart_contracts/smart_contract_examples/6_my_pool/#librs-multiple-staking-commands","title":"lib.rs: multiple staking commands","text":"<pre><code>    #[call]\n    fn multiple_defer(max_amount: u64) {\n        let operator = Self::get_pool_operator();\n        pchain_sdk::network::defer_unstake_deposit(operator, max_amount);\n        pchain_sdk::network::defer_withdraw_deposit(operator, max_amount);\n    }\n</code></pre> <p>Congratulations! You have completed all tutorials and are ready to write your smart contract!</p>","tags":["pchain-sdk","tutorial","Smart Contract","Staking"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/","title":"API Reference","text":"","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#properties","title":"Properties","text":"","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#isxpll","title":"isXPLL","text":"<p>This property is true if the user has the extension installed.</p> <pre><code>window.xpll.isXPLL; // =&gt; true\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#request","title":"Request","text":"<p>The request method is intended as a transport- and protocol-agnostic wrapper function for Remote Procedure Calls (RPCs).</p> <p>If resolved, the Promise will resolve with a result per the RPC method\u2019s specification. If the returned Promise rejects, it will reject with an <code>XPLLProviderRpcError</code> as specified in the Errors section below.</p> <pre><code>interface RequestArguments {\n  readonly method: string;\n  readonly params?: readonly unknown[] | object;\n}\n</code></pre> <pre><code>request(data: RequestArguments): Promise&lt;Result&gt;;\n// or reject with `XPLLProviderRpcError`\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#parameters","title":"Parameters","text":"<ul> <li><code>method</code>: Indicates which RPC method to call</li> <li><code>params</code>: An optional array or object of arguments to pass with the RPC</li> </ul>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#helper-functions","title":"Helper Functions","text":"<p>To improve the developer experience, the Provider also implements a list of helper functions, which helps simplify the RPC method call.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#request-permission","title":"Request Permission","text":"<p>Request permission to access the user's accounts.</p> <p>Warning</p> <p>The request causes a pop-up to appear. You should only request permission in response to a direct user action, such as a button click.</p> <p>Failure</p> <p>If the user rejects the request, the <code>User Rejected Request 4001</code> error will be thrown.</p> <pre><code>interface Permission {\n  id: string;\n  invoker: string;\n  parent_capability: string;\n  caveats: {\n    type: string;\n    value?: unknown;\n  }[];\n  created_at: number;\n}\ninterface RequestPermissionRequest {\n  method: \"request_permissions\";\n}\ntype RequestedPermissionResult = Permission;\n</code></pre> RPCHelper Function <pre><code>window.xpll.request({\n  method: \"request_permissions\"\n});\n</code></pre> <pre><code>window.xpll.requestPermissions();\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#is-wallet-locked","title":"Is Wallet Locked","text":"<p>Return <code>true</code> if the wallet is locked; return <code>false</code> otherwise.</p> <pre><code>interface IsWalletLockedRequest {\n  method: \"is_wallet_locked\";\n}\ntype IsWalletLockedResult = boolean;\n</code></pre> RPCHelper Function <pre><code>window.xpll.request({\n  method: \"is_wallet_locked\"\n});\n</code></pre> <pre><code>window.xpll.isWalletLocked();\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#get-permissions","title":"Get Permissions","text":"<p>Return all permissions that have been granted to the wallet.</p> <pre><code>interface Permission {\n  id: string;\n  invoker: string;\n  parent_capability: string;\n  caveats: {\n    type: string;\n    value?: unknown;\n  }[];\n  created_at: number;\n}\ninterface GetPermissionsRequest {\n  method: \"get_permissions\";\n}\ntype GetPermissionsResult = Permission[];\n</code></pre> RPCHelper Function <pre><code>window.xpll.request({\n  method: \"get_permissions\"\n});\n</code></pre> <pre><code>window.xpll.getPermissions();\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#get-accounts","title":"Get Accounts","text":"<p>Return the list of account addresses owned by the user.</p> <p>Warning</p> <p>The <code>get_accounts</code> should have permission granted; otherwise, the <code>User Rejected Request 4001</code> error will be thrown. Please check Permissions for more details.</p> <pre><code>interface GetAccountsRequest {\n  method: \"get_accounts\";\n}\n\ntype GetAccountsResult = string[];\n</code></pre> RPCHelper Function <pre><code>window.xpll.request({\n  method: \"get_accounts\"\n});\n</code></pre> <pre><code>window.xpll.getAccounts();\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#get-active-account","title":"Get Active Account","text":"<p>Get the address of the currently active account; return <code>undefined</code> if the user still needs to register.</p> <p>Warning</p> <p>The <code>get_active_account</code> should have permission granted; otherwise, the <code>User Rejected Request 4001</code> error will be thrown. Please check Permission for more details.</p> <pre><code>interface GetActiveAccountRequest {\n  method: \"get_active_account\";\n}\ntype GetActiveAccountResult = string | undefined;\n</code></pre> RPCHelper Function <pre><code>window.xpll.request({\n  method: \"get_active_account\"\n});\n</code></pre> <pre><code>window.xpll.getActiveAccount();\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#get-active-account-balance","title":"Get Active Account Balance","text":"<p>Return the balance of the active account in XPLL.</p> <p>Warning</p> <p>The <code>get_active_account_balance</code> should have the permission granted; otherwise, the <code>User Rejected Request 4001</code> error will be thrown. Please check Permission for more details.</p> <pre><code>interface GetActiveAccountBalanceRequest {\n  method: \"get_active_account_balance\";\n}\ntype GetActiveAccountBalanceResult = string;\n</code></pre> RPCHelper Function <pre><code>window.xpll.request({\n  method: \"get_active_account_balance\"\n});\n</code></pre> <pre><code>window.xpll.getActiveAccountBalance();\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#get-active-account-latest-transactions","title":"Get Active Account Latest Transactions","text":"<p>Return the latest transactions of the active account.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#params","title":"Params","text":"<ul> <li><code>limit</code>: The number of transactions to return. The default value is <code>1</code>.</li> <li><code>order</code>: The order of transactions to return. The default value is <code>desc</code>.</li> </ul> <p>Warning</p> <p>The <code>get_active_account_latest_transactions</code> should have the permission granted; otherwise, the <code>User Rejected Request 4001</code> error will be thrown. Please check Permission for more details.</p> <pre><code>interface GetActiveAccountLatestTransactionsRequest {\n  method: \"get_active_account_latest_transactions\";\n  params?: {\n    limit?: number;\n    order?: \"asc\" | \"desc\";\n  };\n}\n\ninterface TransactionSummary {\n  amount: string;\n  block_hash: string;\n  commands: string[];\n  command: string;\n  exit_status?: string;\n  gas_consumed: string;\n  gas_limit: string;\n  hash: string;\n  nonce: string;\n  number: string;\n  signer: string;\n  status: number;\n  timestamp: number;\n  tx_gas_consumption: string;\n}\ntype GetActiveAccountLatestTransactionsResult = TransactionSummary[];\n</code></pre> RPCHelper Function <pre><code>window.xpll.request({\n  method: \"get_active_account_latest_transactions\",\n  params: {\n    limit: 1,\n    order: \"desc\",\n  }\n});\n</code></pre> <pre><code>window.xpll.getActiveAccountLatestTransactions({\n  limit: 1,\n  order: \"desc\",\n});\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#get-current-network","title":"Get Current Network","text":"<p>Return the current network.</p> <pre><code>interface GetCurrentNetworkRequest {\n  method: \"get_current_network\";\n}\ntype GetCurrentNetworkResult = string | undefined;\n</code></pre> RPCHelper Function <pre><code>window.xpll.request({\n  method: \"get_current_network\"\n});\n</code></pre> <pre><code>window.xpll.getCurrentNetwork();\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#send-token","title":"Send Token","text":"<p>Transfer tokens to another account; return the transaction hash if the request is successful.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#params_1","title":"Params","text":"<ul> <li><code>amount</code>: The amount of tokens to transfer in XPLL.</li> <li><code>recipient</code>: The address of the recipient account.</li> <li><code>nonce</code>: The nonce of the transaction.   If not provided, the nonce will be calculated automatically.</li> <li><code>gas_limit</code>: The gas limit of the transaction.   If not provided, the gas limit will be calculated automatically.</li> <li><code>max_base_fee_per_gas</code>: The maximum base fee per gas of the transaction. The default value is <code>8</code>.</li> <li><code>priority_fee_per_gas</code>: The priority fee per gas of the transaction. The default value is <code>0</code>.</li> </ul> <p>Warning</p> <p>The request causes a pop-up to appear. You should only request permissions in response to a direct user action, such as a button click.</p> <p>Failure</p> <p>If the user rejects the request, the <code>User Rejected Request 4001</code> error will be thrown.</p> <p>Tip</p> <p>Send Token is only for XPLL transfers. If you want to transfer the PRFC1 token, we should use Call Contract instead.</p> <pre><code>interface SendTokenRequest {\n  method: \"send_token\";\n  params: {\n    amount: string | number | bigint;\n    recipient: string;\n    nonce?: string | number | bigint;\n    gas_limit?: string | number | bigint;\n    max_base_fee_per_gas?: string | number | bigint;\n    priority_fee_per_gas?: string | number | bigint;\n  };\n}\nexport type SendTokenResult = string; // transaction hash\n</code></pre> RPCHelper Function <pre><code>window.xpll.request({\n  method: \"send_token\",\n  params: {\n    recipient: \"FOg6_UOmsPRs4KOECp3G2UoSS1sUQQH8NSgNa_IkQ_8\",\n    amount: \"1\",\n    gas_limit: \"166350\",\n    nonce: \"17\",\n    max_base_fee_per_gas: \"8\",\n    priority_fee_per_gas: \"0\",\n  },\n});\n</code></pre> <pre><code>window.xpll.sendToken({\n  recipient: \"FOg6_UOmsPRs4KOECp3G2UoSS1sUQQH8NSgNa_IkQ_8\",\n  amount: \"1\",\n});\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#call-contract","title":"Call Contract","text":"<p>Call the method except the view method of the contract; return the transaction hash if the request is successful.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#params_2","title":"Params","text":"<ul> <li><code>method</code>: The method of the contract.</li> <li><code>address</code>: The address of the contract.</li> <li><code>args</code>: The arguments of the contract's method.</li> <li><code>nonce</code>: The nonce of the transaction.   If not provided, the nonce will be calculated automatically.</li> <li><code>gas_limit</code>: The gas limit of the transaction.   If not provided, the gas limit will be calculated automatically.</li> <li><code>max_base_fee_per_gas</code>: The maximum base fee per gas of the transaction. The default value is <code>8</code>.</li> <li><code>priority_fee_per_gas</code>: The priority fee per gas of the transaction. The default value is <code>0</code>.</li> </ul> <p>Warning</p> <p>The request causes a pop-up to appear. You should only request permissions in response to a direct user action, such as a button click.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#arguments-serialization","title":"Arguments Serialization","text":"<p>The arguments of the contract method should be serialized as Uint8Array before passing to the <code>call_contract</code> method.</p> <p>The primitive types are serialized based on Borsh binary serialization format. You can use the library borsh-js to help serialize the arguments.</p> <p>The address is a base64 encoded string.  For more details about the base64 serialization, please check MDN.</p> <p>The option type is also based on Borsh binary serialization format.  For instance, <code>Option&lt;PublicAddress&gt;</code> is serialized as:</p> <pre><code>const address = 'ggYKJ-RGIfs2YVzAW2W5KV39NpPSUIzabo7m0dSC_Hs'; \nconst addressBytes = new TextEncoder().encode(address); // PublicAddress\nconst optionBytes = new Uint8Array([1, ...addressBytes]); // Option&lt;PublicAddress&gt;\n</code></pre> <p>The following example shows how to serialize the arguments:</p> <p>Assume that you want to call the <code>transfer_from()</code> method  of the <code>xXAbY4DmeOHHuRCmE9dXczV38BoO-CTKYeWra8YOlLw</code> PRFC1 contract.</p> <pre><code>import * as borsh from 'borsh';\n\n// PublicAddress\nconst fromAddress = 'YChzIE0ZGwKuuJSSVugZ-SlY3RvBzzjjz3__VkftgCY';\n// Option&lt;PublicAddress&gt;\nconst toAddress = 'ggYKJ-RGIfs2YVzAW2W5KV39NpPSUIzabo7m0dSC_Hs'; \n// u64\nconst value = '0.001'; \n\n// helper functions for serialization\nconst base64ToBytes = (text) =&gt; new TextEncoder().encode(text);\nconst option = (bytes) =&gt; new Uint8Array([1, ...bytes]);\n\nwindow.xpll.request({\n    method: 'call_contract',\n    params: {\n        address: 'xXAbY4DmeOHHuRCmE9dXczV38BoO-CTKYeWra8YOlLw',\n        method: 'transfer_from',\n        args: [\n            base64ToBytes(fromAddress),\n            option(base64ToBytes(toAddress)),\n            borsh.serialize('u64', value),\n        ],\n    }\n});\n</code></pre> <p>Sometimes, it's hard to serialize the arguments by yourself. Hence, the Provider provides a handy way to help you with the argument serialization: by passing in the arguments as an array of objects, as seen below.</p> <pre><code>interface UintArgument {\n    type: 'u8' | 'u16' | 'u32' | 'u64' | 'u128';\n    value: string | number | bigint;\n}\n\ninterface IntArgument {\n    type: 'i8' | 'i16' | 'i32' | 'i64' | 'i128';\n    value: string | number | bigint;\n}\n\ninterface FloatArgument {\n    type: 'f32' | 'f64';\n    value: string | number | bigint;\n}\n\ninterface BoolArgument {\n    type: 'bool';\n    value: boolean;\n}\n\ninterface StringArgument {\n    type: 'string';\n    value: string;\n}\ninterface Base64Argument {\n    type: 'base64';\n    value: string;\n}\n\ntype Argument = UintArgument | IntArgument | FloatArgument | BoolArgument | StringArgument | Base64Argument;\n</code></pre> <p>The following example shows how to serialize the arguments:</p> <pre><code>window.xpll.request({\n    method: 'call_contract',\n    params: {\n        address: 'xXAbY4DmeOHHuRCmE9dXczV38BoO-CTKYeWra8YOlLw',\n        method: 'transfer_from',\n        args: [\n            { type: 'base64', value: 'YChzIE0ZGwKuuJSSVugZ-SlY3RvBzzjjz3__VkftgCY' },\n            { type: 'base64', value: 'ggYKJ-RGIfs2YVzAW2W5KV39NpPSUIzabo7m0dSC_Hs' },\n            { type: 'u64', value: '0.001' }\n        ],\n    }\n});\n</code></pre> <pre><code>interface CallContractRequest {\n  method: \"call_contract\";\n  params: {\n    method: string;\n    address: string;\n    args: Argument[];\n    gas_limit?: string | number | bigint;\n    nonce?: string | number | bigint;\n    max_base_fee_per_gas?: string | number | bigint;\n    priority_fee_per_gas?: string | number | bigint;\n  };\n}\nexport type CallContractResult = string; // transaction hash\n</code></pre> RPCHelper Function <pre><code>window.xpll.request({\n    method: 'call_contract',\n    params: {\n        address: 'xXAbY4DmeOHHuRCmE9dXczV38BoO-CTKYeWra8YOlLw',\n        method: 'transfer_from',\n        args: [\n            { type: 'base64', value: 'YChzIE0ZGwKuuJSSVugZ-SlY3RvBzzjjz3__VkftgCY' },\n            { type: 'base64', value: 'ggYKJ-RGIfs2YVzAW2W5KV39NpPSUIzabo7m0dSC_Hs' },\n            { type: 'u64', value: '0.001' }\n        ],\n    }\n});\n</code></pre> <pre><code>window.xpll.callContract({\n    address: 'xXAbY4DmeOHHuRCmE9dXczV38BoO-CTKYeWra8YOlLw',\n    method: \"transfer_from\",\n    args: [\n        { type: 'base64', value: 'YChzIE0ZGwKuuJSSVugZ-SlY3RvBzzjjz3__VkftgCY' },\n        { type: 'base64', value: 'ggYKJ-RGIfs2YVzAW2W5KV39NpPSUIzabo7m0dSC_Hs' },\n        { type: 'u64', value: '0.001' }\n    ],\n});\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#watch-asset","title":"Watch Asset","text":"<p>Allows developers to request a specified asset be tracked in the wallet.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/api_reference/#params_3","title":"Params","text":"<ul> <li><code>type</code>: The type string is the commonly accepted name of the interface implemented by the asset\u2019s contract, e.g. PRFC1.</li> <li><code>address</code>: The address of the contract.</li> </ul> <p>Warning</p> <p>The <code>watch_asset</code> should have permission granted; otherwise, the <code>User Rejected Request 4001</code> error will be thrown. Please check Permissions for more details.</p> <p>Warning</p> <p>The request causes a pop-up to appear. You should only request permissions in response to a direct user action, such as a button click.</p> <p>Failure</p> <p>If the user rejects the request, the <code>User Rejected Request 4001</code> error will be thrown.</p> <pre><code>interface WatchAssetRequest {\n    method: \"watch_asset\";\n    params: {\n        type: \"PRFC1\";\n        address: string;\n    };\n}\ntype WatchAssetResult = boolean;\n</code></pre> RPCHelper Function <pre><code>window.xpll.request({\n    method: 'watch_asset',\n    params: {\n        type: 'PRFC1',\n        address: 'xXAbY4DmeOHHuRCmE9dXczV38BoO-CTKYeWra8YOlLw'\n    }\n});\n</code></pre> <pre><code>window.xpll.watchAsset({\n    type: 'PRFC1',\n    address: 'xXAbY4DmeOHHuRCmE9dXczV38BoO-CTKYeWra8YOlLw'\n});\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/definitions/","title":"Definitions","text":"","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/definitions/#dapp","title":"Dapp","text":"<p>A decentralised application (dapp) is an application built on a decentralised network that combines a smart contract and a front-end user interface.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/definitions/#provider","title":"Provider","text":"<p>A JavaScript object made available to a consumer, that provides access to a wallet using a Client.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/definitions/#client","title":"Client","text":"<p>An endpoint that receives Remote Procedure Call (RPC) requests from the Provider and returns their results.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/definitions/#wallet","title":"Wallet","text":"<p>An end-user application that manages private keys, performs signing operations, and acts as a middleware between the Provider and the Client.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/definitions/#remote-procedure-call-rpc","title":"Remote Procedure Call (RPC)","text":"<p>A Remote Procedure Call (RPC), is any request submitted to a Provider for some procedure that is to be processed by a Provider, its Wallet, or its Client.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/definitions/#address","title":"Address","text":"<p>An address is a base64url encoded string representation of a public key. It is used to identify users in the network.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/definitions/#active-account","title":"Active Account","text":"<p>An active account is an account that is currently selected by the user in the wallet.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/error/","title":"Errors","text":"<p>The Provider will reject any RPC request with an error object if the RPC request cannot be fulfilled. Every error object should have a <code>code</code> property that indicates the error type that occurred.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/error/#error-type","title":"Error Type","text":"<pre><code>interface XPLLProviderRpcError extends Error {\n  code: number;\n  data?: unknown;\n}\n</code></pre> <p>Tip</p> <p><code>XPLLProviderRpcError</code> is inherited from the native <code>Error</code> object. Since <code>Error</code> is a serializable object, it can be cloned with structuredClone() or copied between Workers using postMessage().</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/error/#provider-errors","title":"Provider Errors","text":"Status code Name Description 4001 User Rejected Request The user rejected the request. 4100 Unauthorized The requested method and/or account has not been authorized by the user. 4200 Unsupported Method The Provider does not support the requested method. 4900 Disconnected The Provider is disconnected from all chains. 4901 Chain Disconnected The Provider is not connected to the requested chain. -32700 Parse error Invalid JSON -32600 Invalid request JSON is not a valid request object -32601 Method not found Method does not exist -32602 Invalid params Invalid method parameters -32603 Internal error Internal JSON-RPC error -32000 Invalid input Missing or invalid parameters -32001 Resource not found Requested resource not found -32002 Resource unavailable Requested resource not available -32003 Transaction rejected Transaction creation failed -32004 Method not supported Method is not implemented -32005 Limit exceeded Request exceeds defined limit -32006 JSON-RPC version not supported Version of JSON-RPC protocol is not supported <p>[<code>4900</code>] is intended to indicate that the Provider is disconnected from all chains, while [<code>4901</code>] is intended to indicate that the Provider is disconnected from a specific chain only. In other words, [<code>4901</code>] implies that the Provider is connected to other chains, just not the requested one.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/event/","title":"Events","text":"<p>The Provider will be implemented per the Node.js EventEmitter API with the following event-handling methods:</p> <ul> <li><code>on</code></li> <li><code>off</code></li> <li><code>addListener</code></li> <li><code>removeListener</code></li> </ul>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/event/#example-usage","title":"Example Usage","text":"<pre><code>function handleActiveAccountChanged(accountAddress) {\n  // handle active account\n}\n// subscribe to the activeAccountChanged event\nwindow.xpll.on(\"activeAccountChanged\", handleActiveAccountChanged);\n// unsubscribe the activeAccountChanged event\nwindow.xpll.off(\"activeAccountChanged\", handleActiveAccountChanged);\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/event/#event-message-type","title":"Event Message Type","text":"<p>When emitted, the event will be emitted with an object argument of the following form:</p> <pre><code>interface ProviderMessage {\n  readonly type: string;\n  readonly data: unknown;\n}\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/event/#network-changed","title":"Network Changed","text":"<p>If the network that the Provider is connected to is changed,    the Provider will emit the event named <code>networkChanged</code> with <code>string</code> as the network id.</p> <pre><code>interface NetworkChangedEvent {\n  readonly type: \"networkChanged\";\n  readonly data: string;\n}\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/event/#active-account-changed","title":"Active Account Changed","text":"<p>If the current active account is changed, the Provider will emit the event named <code>activeAccountChanged</code> with <code>string</code> as the account address.</p> <pre><code>interface ActiveAccountChangedEvent {\n  readonly type: \"activeAccountChanged\";\n  readonly data: string;\n}\n</code></pre> <p>Warning</p> <p>The <code>activeAccountChanged</code> event will only fire after permission has been granted. Please check Permissions for more details.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/event/#lock-state-changed-event","title":"Lock State Changed Event","text":"<p>If the lock state of the wallet is changed, the Provider will emit the event named <code>lockStateChanged</code> with <code>boolean</code> as the wallet lock state.</p> <pre><code>export interface LockStateChangedEvent extends ProviderMessage {\n  readonly type: \"lockStateChanged\";\n  readonly data: boolean;\n}\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/introduction/","title":"Introduction to Xperience Browser Provider APIs","text":"<p>The Xperience Browser Provider API is a Javascript API designed to deliver a friendly developer experience and consistency across clients and applications. </p> <p>Xperience Browser Extension injects a global Javascript API into the browser using the <code>window.xpll</code> provider object. </p> <p>This API is specified by EIP-1193, which promotes wallet interoperability by preventing conflicting interfaces and behaviours between wallets. </p> <p>Xperience Browser Provider API is designed to be minimal, event-driven, and agnostic of transport and RPC protocols. Its functionality is easily extended by defining new RPC methods and message event types.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/introduction/#installing-xperience-browser-extension","title":"Installing Xperience Browser Extension","text":"<p>The extension currently only works on Chrome. Chrome user can install the extension via the Chrome Web Store. </p> <p>If necessary, refer to these instructions on installing Chrome extensions.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/introduction/#faq","title":"FAQ","text":"","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/introduction/#after-installing-the-extension-i-am-still-not-able-to-access-windowxpll-in-my-browser-or-dapp","title":"After installing the extension, I am still not able to access <code>window.xpll</code> in my browser or dapp.","text":"<p>Try refreshing the webpage and make sure the website is a valid http or https website. Restricted sites like <code>chrome://extensions/</code> or <code>about:debugging</code> will not be able to access the injected API.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/introduction/#after-clicking-the-extension-icon-nothing-happens","title":"After clicking the extension icon, nothing happens.","text":"<p>If this is your first time setting up the wallet, a separate notification window will appear. If you are using multiple screens, check if the notification window has appeared on another screen.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/permissions/","title":"Permissions","text":"<p>Wallets mediate interactions between untrusted applications and users\u2019 keys by requesting and getting user permissions.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/permissions/#permission-type","title":"Permission Type","text":"<pre><code>interface Caveat {\n  type: string;\n  value: unknown;\n}\n\ninterface Permission {\n  invoker: string;\n  parentCapability: string;\n  caveats: Caveat[];\n}\n</code></pre>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/permissions/#properties","title":"Properties","text":"<ul> <li>The <code>invoker</code> is a URI used to identify the source of the current dapp (e.g. <code>https://your-site.com/</code>).</li> <li>The term <code>parentCapability</code> refers to the method that is being permitted (e.g. <code>xpll_accounts</code>).</li> <li>The caveats array represents the specific restrictions applied to the permitted method.</li> <li>The type of a <code>Caveat</code> is a string, and the <code>value</code> is an arbitrary JSON value.</li> <li>The value of a <code>Caveat</code> is only meaningful in the context of the type of the <code>Caveat</code>.</li> </ul>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/permissions/#request-permission","title":"Request Permission","text":"<p>Request permission to access the user's accounts.</p> <p>Check out the API documentation Request Permissions for details.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_developers/xperience_browser_provider_apis/permissions/#get-permissions","title":"Get Permissions","text":"<p>Return all permissions that have been granted to the wallet.</p> <p>Check out the API documentation for Get Permissions for details.</p>","tags":["wallet","browser extension","provider API"]},{"location":"for_users/pchain_client_cli/creating_transaction/","title":"Creating Transaction","text":"<p>A transaction is a digitally signed instruction that tells the ParallelChain state machine to execute a sequence of commands. There are different kinds of Commands in ParallelChain protocol. </p> <p><code>pchain_client</code> accepts transaction in json format. This section will demonstrate how to prepare your transaction file and submit it with your account keys.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/creating_transaction/#prepare-transaction-file","title":"Prepare Transaction File","text":"<p><code>pchain_client</code> provides user-friendly way to prepare your transaction file without prior knowledge of JSON (JavaScript Object Notation) format. The transaction file consists of 2 parts: <code>Parameters</code> and <code>Subcommand</code>.</p> <p>Here are some CLI subcommands to indicate corresponding Protocol Transaction Command. </p> Subcommand Action Description transfer Transfer balance from transaction signer to recipient deploy Deploy smart contract to the state of the blockchain call Trigger method call of a deployed smart contract deposit Deposit some balance into the network account create Instantiation of a Deposit of an existing Pool top-up Increase balance of an existing Deposit withdraw Withdraw balance from an existing Deposit update-settings Update settings of an existing Deposit stake Stake to a particular pool stake Increase stakes to an existing Pool unstake Remove stakes from an existing Pool pool Create and manage Pool create Instantiation of a Pool in the network account update-settings Update settings of an existing Pool delete Delete an existing Pool in the network account","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/creating_transaction/#create-new-transaction-file","title":"Create New Transaction File","text":"<p><code>Transaction</code> in ParallelChain protocol specifies a set of parameters included in the instruction. You don't need to provide all parameters, some of them would be computed and filled in automatically when you submit the transaction.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create --help\n</code></pre> <pre><code>./pchain_client.exe transaction create --help\n</code></pre> <p>First, provide the following 4 parameters:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n  --nonce &lt;NONCE&gt; \\\n  --gas-limit &lt;GAS_LIMIT&gt; \\\n  --max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; \\\n  --priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; \\\n...\n</code></pre> <pre><code>./pchain_client.exe transaction create `\n  --nonce &lt;NONCE&gt; `\n  --gas-limit &lt;GAS_LIMIT&gt; `\n  --max-base-fee-per-gas &lt;MAX_BASE_FEE_PER_GAS&gt; `\n  --priority-fee-per-gas &lt;PRIORITY_FEE_PER_GAS&gt; `\n...\n</code></pre> <p>Then, decide the transaction type using the CLI subcommand. Each of them takes different inputs. You can always check the help menu using <code>--help</code>.</p> <p>Make sure you provide both <code>Parameters</code> and <code>Subcommand</code> parts in one command. The output transaction file (tx.json) will be saved in the current directory. You can also specify the designated file with the flag <code>--destination</code></p> <p>Example - Transfer tokens:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n  --nonce 0 \\\n  --gas-limit 100000 \\\n  --max-base-fee-per-gas 8 \\\n  --priority-fee-per-gas 0 \\\n  transfer \\\n    --recipient kRPL8cXI73DNgVSSQz9WfIi-mAAvFvdXKfZ9UPBEv_A \\\n    --amount 100\n</code></pre> <pre><code>./pchain_client.exe transaction create `\n  --nonce 0 `\n  --gas-limit 100000 `\n  --max-base-fee-per-gas 8 `\n  --priority-fee-per-gas 0 `\n  transfer `\n    --recipient kRPL8cXI73DNgVSSQz9WfIi-mAAvFvdXKfZ9UPBEv_A `\n    --amount 100\n</code></pre> <p>Example - Deploy contract and save to designated file <code>deposit-tx.json</code>:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction create \\\n--destination ~/Documents/deposit-tx.json \\\n--nonce 0 \\\n--gas-limit 500000000 \\\n--max-base-fee-per-gas 8 \\\n--priority-fee-per-gas 0 \\\ndeploy \\\n  --contract-code /home/document/code.wasm \\\n  --cbi-version 0\n</code></pre> <pre><code>./pchain_client.exe transaction create `\n--destination ~/Documents/deposit-tx.json `\n--nonce 0 `\n--gas-limit 500000000 `\n--max-base-fee-per-gas 8 `\n--priority-fee-per-gas 0 `\ndeploy `\n  --contract-code /home/document/code.wasm `\n  --cbi-version 0\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/creating_transaction/#append-command-to-existing-file","title":"Append Command to Existing File","text":"<p>As explained in the beginning of Transaction section, Transaction in ParallelChain protocol accepts sequence of commands. But you may find that <code>transaction create</code> in previous section only support a single Command in Transaction. </p> <p>If you want to support multiple Commands, use the following command with the subcommand. This appends a <code>Command</code> element to the back of the command array in Transaction. Please note that commands in array will be executed in sequential order.</p> <p>Example:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction append \\\n--file ~/Documents/deposit-tx.json \\\ntransfer \\\n  --recipient kRPL8cXI73DNgVSSQz9WfIi-mAAvFvdXKfZ9UPBEv_A \\\n  --amount 100\n</code></pre> <pre><code>./pchain_client.exe transaction append `\n--file ~/Documents/deposit-tx.json `\ntransfer `\n  --recipient kRPL8cXI73DNgVSSQz9WfIi-mAAvFvdXKfZ9UPBEv_A `\n  --amount 100\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/creating_transaction/#submit-transaction-to-parallelchain","title":"Submit Transaction to ParallelChain","text":"<p>After preparing the transaction json file, you can now submit the transaction with keypair.</p> <p>Note</p> <p>Executing transactions may require paying for gas fees. If you are testing transactions on Parallelchain Testnet, you can get free testnet tokens from the Faucet Service to pay for the gas fees.</p> <p>Example:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client transaction submit \\\n--file &lt;FILE&gt; \\\n--keypair-name &lt;KEYPAIR_NAME&gt;\n</code></pre> <pre><code>./pchain_client.exe transaction submit `\n--file &lt;FILE&gt; `\n--keypair-name &lt;KEYPAIR_NAME&gt;\n</code></pre> <p>You will get a response like the following example if the transaction is accepted by your provider. <pre><code>{\n  \"API Response:\": \"Your Transaction has been received.\",\n  \"Command(s):\": [\n    {\n      \"Deploy\":\n      {\n        \"cbi_version\": 0,\n        \"contract\": \"&lt;contract in 53476 bytes&gt;\"\n      }\n    }\n  ],\n  \"Contract Address:\": \"EH-0Im5Pb5mZQumIP6AAxyqTU7fBWQsNfLdGfaBh8AE\",\n  \"Signature:\": \"DdRr2l-f3SwWtQP7M5JKdOUEvIb-th2mBrV1z06dkvB2rpp0qKQZwBBzJBh8czCqplUsmzSlSjPNrvOQbx2jAA\",\n  \"Transaction Hash:\": \"POikFlLT8sVuVt3RHJvxmzPKP8dfvi55TrME6Muc80I\"\n}\n</code></pre></p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/getting_started/","title":"Getting Started","text":"<p>ParallelChain Client CLI (<code>pchain_client</code>) is an easy-to-use, fully-featured CLI for interacting with ParallelChain.  For a detailed description of all available commands, execute <code>pchain_client --help</code>. </p> <p>Usage</p> <pre><code>ParallelChain Client CLI 0.4.4\n&lt;ParallelChain Lab&gt;\nParallelChain client (`pchain_client`) is a command-line tool for you to connect and interact with\nthe ParallelChain Mainnet/Testnet.\n\nUSAGE:\n    pchain_client &lt;SUBCOMMAND&gt;\n\nOPTIONS:\n    -h, --help       Print help information\n    -V, --version    Print version information\n\nSUBCOMMANDS:\n    transaction    Construct and submit Transactions to ParallelChain network\n    query          Query blockchain and world state information for ParallelChain network\n    keys           Locally stores and manage account keypairs you created. (Password required)\n    parse          Utilities functions to deserialize return values in CommandReceipt, and\n                       compute contract address\n    config         Get and set Fullnode RPC url to interact with ParallelChain\n    help           Print this message or the help of the given subcommand(s)\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/getting_started/#installing-parallelchain-client-cli","title":"Installing ParallelChain Client CLI","text":"<p><code>pchain_client</code> is an available tool for users on Unix/Linux, MacOS, and Windows operating systems. Simply download the pre-built binary corresponding to your platform and install the <code>pchain_client</code>.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/getting_started/#windows","title":"Windows","text":"<ol> <li>Download the latest release as a compressed file from Assets of ParallelChain Lab's GitHub release page.</li> <li>Unzip the file to extract the executable <code>pchain_client.exe</code>.</li> <li>Open Powershell by pressing WIN+R and typing <code>powershell</code>.</li> <li>Navigate to the directory where <code>pchain_client.exe</code> is located using the <code>cd</code> command. For example, if the executable is located at <code>C:\\Development</code>, type <code>cd C:\\Development</code>.</li> <li>Follow the instructions in Section Preparing Environment to get ready for interacting with the blockchain.</li> </ol>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/getting_started/#linux-macos","title":"Linux / macOS","text":"<p>The installation process for Linux and macOS is similar. To install <code>pchain_client</code>:</p> <ol> <li> <p>Download the latest release as a compressed file from Assets of ParallelChain Lab's GitHub release page.</p> </li> <li> <p>Head to the directory where the downloaded file is located and extract it using <code>tar</code>. For example:</p> LinuxmacOS <pre><code>tar -xvf pchain_client_linux_v0.4.4.tar.gz\n</code></pre> <pre><code>tar -xvf pchain_client_mac_v0.4.4.tar.gz\n</code></pre> </li> <li> <p>Follow the instructions in Section Preparing Environment to get ready for interacting with the blockchain.</p> </li> </ol> <p>Tips</p> <ul> <li> <p>If you're using macOS and encounter a GateKeeper message when trying to run pchain_client, you can remove macOS' \"GateKeeper\" attributes from pchain_client using the following command: <pre><code>sudo xattr -rd com.apple.quarantine ./pchain_client\n</code></pre> This is an elevated action, so you will need to enter your password to continue. <code>pchain_client</code> can now be used as normal.</p> </li> <li> <p>You might want to store <code>pchain_client</code> in a directory of your choice so that it is easier to follow the commands in the tutorial. For example, we created a folder in our home directory called parallelchain_client: <pre><code>$ mkdir -p /home/my_user/parallelchain_client\n$ cp pchain_client /home/my_user/parallelchain_client/\n$ cd /home/my_user/parallelchain_client\n$ ./pchain_client\n</code></pre></p> </li> </ul> <p>Note</p> <p>If this is your first time using <code>pchain_client</code>, you need to set up <code>$PCHAIN_CLI_HOME</code> in environment variables to specify the home path. See more here.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/getting_started/#preparing-environment","title":"Preparing Environment","text":"","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/getting_started/#set-environmental-variables","title":"Set Environmental Variables","text":"<p>Specify the location of the directory for storing your config and keypair by setting the environmental variable <code>PCHAIN_CLI_HOME</code>. </p> <p>Always remember the location that you set, if you forget the location, it means you forget where your keypair is being placed.</p> <p>Tips</p> <p>For security reasons, you may want to set environmental temporarily, so that after you close the terminal session, it will forget the keypair location.</p> <p>For convenience reasons, you may alternatively want to set environmental permanently. Even in that case, we still suggest you remember the storage location.</p> <p>The following command will set the environmental variable temporarily:</p> Linux / macOSWindows PowerShell <pre><code># For example, \"/home/user/pchain_cli_home\"\nexport PCHAIN_CLI_HOME=\"&lt;PATH_TO_DIRECTORY&gt;\"\n</code></pre> <pre><code># For example, \"C:\\Users\\user\\pchain_cli_home\"\n$Env:PCHAIN_CLI_HOME=\"&lt;PATH_TO_DIRECTORY&gt;\"\n</code></pre> <p>The following command will set the environmental variable permanently:</p> Linux / macOSWindows PowerShell (restart shell to pick up change) <pre><code>##########################################################\n## Append this line to $Home/.bashrc and $Home/.profile ##\n##########################################################\nexport PCHAIN_CLI_HOME=\"&lt;PATH_TO_DIRECTORY&gt;\"\n</code></pre> <pre><code>setx PCHAIN_CLI_HOME \"&lt;PATH_TO_DIRECTORY&gt;\"\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/getting_started/#setup-endpoint","title":"Setup Endpoint","text":"<p>After installation of <code>pchain_client</code>, you had to update the Mainnet / Testnet endpoint to communicate with the Mainnet / Testnet. </p> Linux / macOSWindows PowerShell <pre><code># Mainnet\n./pchain_client config setup --url https://pchain-main-rpc02.parallelchain.io\n\n# Testnet\n./pchain_client config setup --url https://pchain-test-rpc02.parallelchain.io\n</code></pre> <pre><code># Mainnet\n./pchain_client.exe config setup --url https://pchain-main-rpc02.parallelchain.io\n\n# Testnet\n./pchain_client.exe config setup --url https://pchain-test-rpc02.parallelchain.io\n</code></pre> <p>This would check the status of your chosen provider. If <code>pchain_client</code> cannot connect to your provider, a warning message will be shown, and the setup fails. You need to set up another URL with the above command again.</p> <p>A <code>config.toml</code> file will be created in the folder specified by the environment variable <code>PCHAIN_CLI_HOME</code> upon success. It only needs to be executed once.</p> <p>Now you can start the journey to play around with <code>pchain_client</code>!</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/getting_started/#running-pchain_client","title":"Running pchain_client","text":"","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/getting_started/#create-password","title":"Create Password","text":"<p>For the first time to use <code>pchain_client</code>, you need to create your password for using it. The terminal should prompt you as follows:</p> <pre><code>First time using ParallelChain Client CLI. Please set up a password to protect your keypairs.\nYour password: \n</code></pre> <p>This password is only used by the CLI, and NOT associated with the blockchain. It is used for encryption and decryption of your keypairs so that the keypairs are stored in your computer more securely. Alternatively, you can skip the password protection by simply pressing Enter.</p> <p>You will be required to enter your password twice. If your password is set successfully, you will see a return message with the <code>pchain_client</code> version shown on the console.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client --version\n</code></pre> <pre><code>./pchain_client.exe --version\n</code></pre> <p>Warning</p> <p>The password is not sent and saved anywhere. You won't be able to recover the password if you lose it. Please keep your password safe. You will be required to provide this password to submit transactions and manage keypairs later.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/interacting_with_smart_contract/","title":"Interacting with Smart Contract","text":"<p>Smart contracts are computer programs that are stored on a blockchain. You need to provide some necessary information such as contract address, method name, and arguments in order to invoke method of the contract.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/interacting_with_smart_contract/#retrieve-contract-address","title":"Retrieve Contract Address","text":"<p>After you deploy the contract in a transaction, you should receive the contract address together with transaction hash. If you want to deploy contract and call method in the SAME transaction, it is possible to compute the contract address in advance.</p> <p>You need to provide the account address and nonce when deploying the contract.</p> <p>Command:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client parse contract-address --address &lt;ADDRESS&gt; --nonce &lt;NONCE&gt;\n</code></pre> <pre><code>./pchain_client.exe parse contract-address --address &lt;ADDRESS&gt; --nonce &lt;NONCE&gt;\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/interacting_with_smart_contract/#prepare-contract-method-arguments-file","title":"Prepare Contract Method Arguments File","text":"<p>When you make a contract call that modifies or views state, the contract method may expect arguments. You need to provide arguments by JSON file(.json) with <code>transaction create call</code> or <code>query view</code> commands.</p> <p>Example: For a contract method that accepts 3 arguments (String, Vec , boolean) <pre><code>{\n    \"arguments\": [\n        {\"argument_type\": \"String\", \"argument_value\": \"Yuru Camp\"},\n        {\"argument_type\": \"Vec&lt;i16&gt;\", \"argument_value\":\"[-1, 20]\"},\n        {\"argument_type\": \"bool\", \"argument_value\": \"true\"}\n    ]\n}\n</code></pre> Each object in an arguments array consists of two fields, <code>argument_type</code> and <code>argument_value</code>. Here are some acceptable types and values. Type Description Example <code>i8</code> The 8-bit signed integer type \"-128\" <code>i16</code> The 16-bit signed integer type \"-32768\" <code>i32</code> The 32-bit signed integer type \"-2147483648\" <code>i64</code> The 64-bit signed integer type \"-9223372036854775808\" <code>u8</code> The 8-bit unsigned integer type \"255\" <code>u16</code> The 16-bit unsigned integer type \"65535\" <code>u32</code> The 32-bit unsigned integer type \"4294967295\" <code>u64</code> The 64-bit unsigned integer type \"18446744073709551615\" <code>String</code> String \"\\\"This is test string\\\"\" <code>bool</code> Boolean \"true\" or \"false\" <code>Vec&lt;TYPE&gt;</code> Array with specific type and arbitrary length \"[65535,6535]\" , \"[true,false,true]\" <code>[5]</code> Array with specific length \"[1,2,3,4,5]\"","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/managing_account/","title":"Managing Account","text":"<p>In ParallelChain, an account is identified by the public key of Ed25519 keypair. You can either generate new keys or import your existing Ed25519 keypair to make transactions in <code>pchain_client</code>. Both operations require password (if you setup before).</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/managing_account/#generate-new-keypair","title":"Generate New Keypair","text":"<p>This command generates a set of ed25519_dalek compatible keys. Random name will be set if you do not provide a name.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client keys create --name &lt;NAME&gt;\n</code></pre> <pre><code>./pchain_client.exe keys create --name &lt;NAME&gt;\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/managing_account/#import-existing-keypair","title":"Import Existing Keypair","text":"<p>If you have already got keys from ParallelChain Explorer, you can import your account keypair with this command. Random name will be set if you do not provide a name.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client keys import --private &lt;PRIVATE_KEY&gt; --public &lt;PUBLIC_KEY/ADDRESS&gt; --name &lt;NAME&gt;\n</code></pre> <pre><code>./pchain_client.exe keys import --private &lt;PRIVATE_KEY&gt; --public &lt;PUBLIC_KEY/ADDRESS&gt; --name &lt;NAME&gt;\n</code></pre> <p><code>PRIVATE_KEY</code> and <code>PUBLIC_KEY/ADDRESS</code> are Base64url encoded.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/managing_account/#list-accounts","title":"List Accounts","text":"<p>After creating or adding keypair, you can check it using the following command to list out all public keys managed in this tool.</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client keys list\n</code></pre> <pre><code>./pchain_client.exe keys list\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/querying_blockchain/","title":"Querying Blockchain","text":"<p><code>pchain_client</code> allows you to query different data from the ParallelChain, not just Transaction or Account related information, but also details of Validators and Stake Pool in ParallelChain network. </p> <p>Use <code>pchain_client query --help</code> to check the full list available to query.</p>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/querying_blockchain/#check-account-related-information","title":"Check Account Related Information","text":"<p>Note</p> <p>If you don't have access to an account yet, check \"See also\" under How Account Works to create an account.</p> <p>To check Externally Owned Accounts (EOA) information such as balance and nonce, your account address (public key) is always needed.</p> <p>Commands:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query balance --address &lt;ADDRESS&gt;\n./pchain_client query nonce --address &lt;ADDRESS&gt;\n</code></pre> <pre><code>./pchain_client.exe query balance --address &lt;ADDRESS&gt;\n./pchain_client.exe query nonce --address &lt;ADDRESS&gt;\n</code></pre> <p>For Contract Account, you can use another command to download the contract code binary file (wasm).</p> <p>Command:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query contract --address &lt;ADDRESS&gt;\n</code></pre> <pre><code>./pchain_client.exe query contract --address &lt;ADDRESS&gt;\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/querying_blockchain/#get-transaction-with-receipt","title":"Get Transaction with Receipt","text":"<p>In Submit Transaction to ParallelChain section, after you successfully make transaction on ParallelChain, you should receive the transaction hash (tx_hash) in the response. This hash is the identity of your transaction. You can always retrieve the transaction details with receipt by the transaction hash.</p> <p>Command:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query tx --hash &lt;TX_HASH&gt;\n</code></pre> <pre><code>./pchain_client.exe query tx --hash &lt;TX_HASH&gt;\n</code></pre> <p>If you just want to get the receipt, you can use following command</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query receipt --hash &lt;TX_HASH&gt;\n</code></pre> <pre><code>./pchain_client.exe query receipt --hash &lt;TX_HASH&gt;\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/pchain_client_cli/querying_blockchain/#get-deposit-and-stake","title":"Get Deposit and Stake","text":"<p>You can query deposit or stake amount of an account from a specific pool stored in Network Account.</p> <p>Commands:</p> Linux / macOSWindows PowerShell <pre><code>./pchain_client query deposit --operator &lt;OPERATOR&gt; --owner &lt;OWNER&gt;\n./pchain_client query stake --operator &lt;OPERATOR&gt; --owner &lt;OWNER&gt;\n</code></pre> <pre><code>./pchain_client.exe query deposit --operator &lt;OPERATOR&gt; --owner &lt;OWNER&gt;\n./pchain_client.exe query stake --operator &lt;OPERATOR&gt; --owner &lt;OWNER&gt;\n</code></pre>","tags":["Tools","CLI","pchain-cli-rust"]},{"location":"for_users/web_wallet/create_account/","title":"Creating and Managing Your Account","text":"<p>You can use Web Wallet on ParallelChain Explorer on without any installation.</p> <p>To conduct transactions on ParallelChain Mainnet you will first need to create an account on the blockchain to access the network. Accounts are free to create, and they can be set up through ParallelChain Explorer\u2014or through the new Xperience Browser Extension.</p> <p>The account (EOA) you create on ParallelChain is non-custodial, which means only you have control and access to it. You must store your recovery key securely and properly to avoid losing access to your assets. There is no way to retrieve it if it is lost.</p> <p>Learn how to create and manage your ParallelChain account using ParallelChain Explorer with the steps below.</p>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#creating-your-parallelchain-wallet-account","title":"Creating Your ParallelChain Wallet Account","text":"","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#access-parallelchain-explorer","title":"Access ParallelChain Explorer","text":"<p>Access ParallelChain Explorer to start your account creation process.</p>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#create-your-account","title":"Create Your Account","text":"<ol> <li>Create your ParallelChain wallet account by selecting CONNECT NOW.</li> <li>Click the REGISTER button.</li> <li>Your 12-word recovery key will be generated automatically. You should copy your recovery key by clicking COPY AS TEXT and pasting it in a secure document, or you should write it down. Store it in a safe and secure location.</li> <li>Take note that the phrases are stored in a chronological order.</li> <li>Click NEXT once you have stored it safely</li> </ol>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#verify-your-recovery-key","title":"Verify Your Recovery Key","text":"<ol> <li>To make sure that your recovery key are stored securely, you will be prompted to fill in blanks which correspond to the phrases displayed in the previous step.</li> <li>Enter the words which correspond to the chronological positions of the recovery key.</li> <li>Press NEXT when you are done.</li> <li>If an error message appears, refer to your recovery key again and check if you have keyed in the wrong phrase.</li> </ol>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#create-your-password","title":"Create Your Password","text":"<ol> <li>Create a password for your wallet. Your password can contain any characters, and it must be at least 8 characters long.</li> <li>This password is only limited to the wallet access on the particular device you are registering your account on, and it cannot be used on another device.</li> <li>Under Confirm Password, enter your password again. If you receive a Password mismatched error, please re-enter your password again and check that both of them are exactly the same.</li> <li>Press the REGISTER button to proceed.</li> <li>You will be prompted to enter your password again to access your wallet. Enter your password in the empty field, then click VERIFY.</li> </ol>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#login-your-wallet","title":"Login Your Wallet","text":"<ol> <li>To log in, click on the round icon on the top right hand corner of the webpage and enter your password</li> <li>Press the VERIFY button.</li> <li>If you do not remember your password, you can choose to log in with your recovery key. Start by selecting FORGOT PASSWORD.</li> <li>Re-enter your 12-phrase recovery key that you have stored securely when you first created your wallet, then press NEXT.</li> <li>Create a password for your wallet. Your password can contain any characters, and it must be at least 8 characters long.</li> <li>Under Confirm Password, enter your password again. If you receive a Password mismatched error, please re-enter your password again and check that both of them are exactly the same.</li> <li>Press the REGISTER button to proceed. You can now access your wallet account.</li> </ol>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#importing-an-existing-wallet","title":"Importing An Existing Wallet","text":"<ol> <li>To import an existing ParallelChain wallet, click on the round icon on the top right hand corner of the webpage, followed by IMPORT EXISTING WALLET.</li> <li>Enter your 12-phrase recovery key that you have stored securely when you first created your wallet, then press NEXT.</li> <li>Next, enter your desired password and re-enter it under the Confirm Password box, then press REGISTER.</li> <li>You will be prompted to enter your password again to access your wallet. Enter your password in the empty field, and select VERIFY.</li> <li>Importing your wallet only recovers accounts associated with the recovery key. Refer to the steps under Export Your Account and Import Your Account From Public And Private Keys to export and import individual accounts.</li> </ol>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#configuring-security-login","title":"Configuring Security &amp; Login","text":"","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#view-your-recovery-key","title":"View Your Recovery Key","text":"<ol> <li>Click the icon with three dots on the top right hand corner of the wallet.</li> <li>To view your recovery key, tap on Security &amp; Login, then enter your current password, followed by VERIFY.</li> <li>If you do not remember your password, you can choose to log in with your recovery key by selecting VERIFY WITH RECOVERY KEY and re-entering your 12-phrase recovery key.</li> <li>Tap on VIEW RECOVERY KEY to preview your recovery key.</li> </ol>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#change-your-password","title":"Change Your Password","text":"<ol> <li>Click the icon with three dots on the top right hand corner of the wallet.</li> <li>To change passwords, tap on Security &amp; Login, then enter your current password, followed by VERIFY.</li> <li>If you do not remember your password, you can choose to log in with your recovery key by selecting VERIFY WITH RECOVERY KEY and re-entering your 12-phrase recovery key.</li> <li>Tap on Change Password to change your password. Enter the new password in the Password field, then enter your password again under Confirm Password. If you receive a Password mismatched error, please re-enter your password again and check that both of them are exactly the same.</li> <li>Press the SAVE CHANGES button to proceed.</li> <li>You will be prompted to enter your password again to access your wallet. Enter your password in the empty field.</li> </ol>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#erase-wallet-from-device","title":"Erase Wallet From Device","text":"<ol> <li>Click the icon with three dots on the top right hand corner of the wallet.</li> <li>To erase your wallet from the current device, tap on Security &amp; Login, then enter your current password, followed by VERIFY.</li> <li>Tap on ERASE WALLET FROM DEVICE, and you will be prompted with a warning that the action cannot be undone. Select ERASE if you wish to proceed, or select CANCEL if you do not want to erase your wallet from the device.</li> <li>You will be prompted to enter your password again to confirm your action. Key in your password in the Password field and select VERIFY.</li> <li>If you do not remember your password, you can choose to log in with your recovery key by selecting VERIFY WITH RECOVERY KEY and re-entering your 12-phrase recovery key.</li> <li>You will be shown a loading screen that says Erasing Wallet Data. Your wallet data has now been removed from your device.</li> </ol>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#export-your-account","title":"Export Your Account","text":"<ol> <li>To export an existing account, click on the drop-down arrow right beside your wallet address. Your wallet address acts as your public key.</li> <li>Click on the key icon to preview your account private key.</li> <li>Save your public and private key in a secure location.</li> <li>You can also download the key pair of your current account through the download icon beside your wallet address as a JSON file.</li> <li>Store the JSON file in a secure manner. If you wish to recover your account on another wallet, you can do so by following the instructions under Import Your Account From Public And Private Keys, or import it with the JSON file under Import Your Account From a JSON file. You can view the information by opening the file with a text-based document such as Microsoft Word.</li> </ol>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#import-your-account-from-public-and-private-keys","title":"Import Your Account From Public And Private Keys","text":"<ol> <li>To import an existing account, click on the drop-down arrow right beside your wallet address</li> <li>Click the IMPORT button.</li> <li>Enter your desired account name under the Account Name</li> <li>Enter your public key in the Public Key field.</li> <li>Enter your private key in the Private Key field.</li> <li>If you are not sure where to find your public and private key, learn how to find them under Export Your Account.</li> <li>Click IMPORT once you are done.</li> </ol>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#import-your-account-from-a-json-file","title":"Import Your Account From a JSON file","text":"<ol> <li>To import an existing account, click on the drop-down arrow right beside your wallet address.</li> <li>Click the IMPORT button</li> <li>Click on Import With File and select the appropriate JSON file. Learn how to export your JSON file under Export Your Account.</li> <li>Once you are done, click on IMPORT and your account will be added to the wallet.</li> </ol>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#lock-your-wallet","title":"Lock Your Wallet","text":"<ol> <li>Click the icon with three dots on the top right hand corner of the wallet.</li> <li>Tap on LOCK WALLET to keep your wallet locked.</li> <li>You will be prompted to enter your password to access your wallet. Enter your password in the empty field and press VERIFY\u2019.</li> </ol>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#navigating-your-parallelchain-wallet","title":"Navigating Your ParallelChain wallet","text":"<ol> <li>Congratulations on creating your ParallelChain account.</li> <li>Your first account will be automatically created for you.</li> <li>You will find your account address on the top. Click to copy if needed.</li> <li>Your XPLL balance is shown in the Balance (XPLL) field.</li> <li>The SEND button and STAKE button allows you to send XPLL tokens to others, or stake XPLL tokens with network validators.</li> <li>You can tap the SEND button to start transferring XPLL tokens to other users.</li> <li>The top right corner of the wallet is indicated by three dots which lets you navigate to your wallet settings</li> <li>If you are unsure of any particular steps while following the tutorial guide, you can also watch the video tutorial here.</li> </ol>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#faq","title":"FAQ","text":"","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#are-my-parallelchain-wallet-and-account-the-same-thing","title":"Are my ParallelChain wallet and account the same thing?","text":"<p>No, your wallet and your account are not the same. Your account is registered on ParallelChain Mainnet, and your wallet extension helps connect you to your account. This means you are able to recover your account should you lose the device that your wallet extension is installed.</p>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#what-kind-of-digital-assets-can-i-store-in-my-xperience-account","title":"What kind of digital assets can I store in my Xperience account?","text":"<p>Currently, it can store XPLL. In the near future, you will be able to store other ParallelChain-based cryptocurrencies and non-fungible tokens (NFTs).</p>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#can-i-send-xpll-tokens-to-other-blockchains-like-ethereum","title":"Can I send XPLL tokens to other blockchains like Ethereum?","text":"<p>No, you cannot send XPLL tokens to other blockchains at the moment. XPLL and other PRFC tokens currently only exist on ParallelChain Mainnet network, and sending your tokens to other network addresses will cause you to lose your tokens.</p>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#what-happens-if-i-lose-my-recovery-key-and-password","title":"What happens if I lose my recovery key and password?","text":"<p>Xperience is a non-custodial wallet which only you have the access to. If you lose your recovery key and password, you will lose access to any asset that is stored in it. We recommend that you write down your recovery key and store it in a secure place, or follow the steps under Exporting Your Account With Public &amp; Private Keys.</p> <p>If you have lost access to your existing account, you can opt to create a new account by clearing the cache of your current browser, then refreshing the page. After that, create a new account by following the steps under Creating Your ParallelChain Wallet Account. Please check online to find out how you can clear your respective browser caches.</p>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#are-xperience-and-parallel-wallet-different","title":"Are Xperience and Parallel wallet different?","text":"<p>Yes, Xperience and ParallelWallet are two different types of non-custodial wallets. You can store XPLL on both wallets, but the recovery keys are not interchangeable and you should still store them in a secure manner.</p>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/create_account/#is-the-wallet-in-xperience-browser-extension-the-same-as-the-wallet-in-parallelchain-explorer","title":"Is the wallet in Xperience Browser Extension the same as the wallet in ParallelChain Explorer?","text":"<p>Yes, they are the same. You can access your wallet through either Xperience Browser Extension or ParallelChain Explorer.</p>","tags":["Xperience","explorer"]},{"location":"for_users/web_wallet/lockup_contract/","title":"Lock-Up Contract","text":"<p>Your XPLL allocation might be subject to a vesting schedule that determines how many of your tokens are vested (unlocked) as time goes on. In order to claim the unlocked portion in the future, you need to first register the Lock-up Contract of your allocation to your account. </p> <p>Note</p> <p>Each Lock-up Contract is unique to each holder. </p> <p>Follow the steps below to register your Lock-up Contract to your ParallelChain wallet account. You can also watch the video tutorial here.</p>","tags":["Xperience","explorer","lockup contract"]},{"location":"for_users/web_wallet/lockup_contract/#logging-in-your-wallet","title":"Logging in Your Wallet","text":"<ol> <li>Access the ParallelChain Explorer, or click on the EXPLORER button on the ParallelChain homepage.</li> <li>To log in, click on the round icon on the top right hand corner of the explorer page and enter your password.</li> <li>Press the LOGIN button.</li> <li>If you do not remember your password, you can choose to log in with your recovery key. Once you have access to your account, you should set a new password through your wallet settings.</li> <li>Once you are verified, you can access your wallet account.</li> </ol>","tags":["Xperience","explorer","lockup contract"]},{"location":"for_users/web_wallet/lockup_contract/#registering-your-lock-up-contract","title":"Registering Your Lock-Up Contract","text":"","tags":["Xperience","explorer","lockup contract"]},{"location":"for_users/web_wallet/lockup_contract/#step-1-get-your-lock-up-contract-address","title":"Step 1: Get Your Lock-Up Contract Address","text":"<ol> <li>Your lock-up contract address would have been sent to you via email. Check your email and copy your lock-up contract address.</li> </ol>","tags":["Xperience","explorer","lockup contract"]},{"location":"for_users/web_wallet/lockup_contract/#step-2-register-your-lock-up-contract","title":"Step 2: Register Your Lock-Up Contract","text":"<ol> <li>Click the pink icon located on the right side of the STAKE button.</li> <li>You will be asked to enter your Lock-up Contract address that has been sent to you via email. To proceed, paste the address in the INPUT CONTRACT ADDRESS field, then click Register.</li> <li>The balance of locked tokens is displayed under the LOCKED field, whereas the amount of vested tokens is shown under the UNLOCKED field. You will have to manually claim the vested tokens to have them transferred to your normal account.</li> <li> <p>Your account comes with a small amount of XPLL to pay for the gas fee for the first transaction.</p> <p> </p> </li> <li> <p>Click the CONFIRM button to confirm.</p> </li> </ol> <p>Note</p> <p>For Node Round participants who will operate validator nodes on ParallelChain, the locked balance shown will be 0 as your allocation has been automatically staked on one of the existing validator nodes.</p> <p>Watch the video tutorial to register your locked-up contract here.</p>","tags":["Xperience","explorer","lockup contract"]},{"location":"for_users/web_wallet/lockup_contract/#claiming-your-vested-tokens","title":"Claiming Your Vested Tokens","text":"","tags":["Xperience","explorer","lockup contract"]},{"location":"for_users/web_wallet/lockup_contract/#step-1-check-your-vested-balance","title":"Step 1: Check Your Vested Balance","text":"<ol> <li> <p>Click the pink icon located on the right side of the STAKE button.</p> </li> <li> <p>On the main display of your account, make sure that you can view your Lock-up Contract (XPLL) which is shown beside your main balance.</p> </li> <li> <p>Tap on the Lock-up Contract (XPLL) window. It will expand to display different fields.</p> <ul> <li>LOCKED - the tokens that currently cannot be claimed.</li> <li>UNLOCKED - the tokens that currently can be claimed.</li> <li>CURRENT PHASE - the vesting phase it is in at the moment.</li> <li>NEXT PHASE - the amount of time left before your tokens are vested</li> </ul> </li> <li> <p>Under tte UNLOCKED field, you can see the amount of tokens that is currently available to claim (unlock).</p> </li> </ol>","tags":["Xperience","explorer","lockup contract"]},{"location":"for_users/web_wallet/lockup_contract/#step-2-claim-your-vested-tokens","title":"Step 2: Claim Your Vested Tokens","text":"<ol> <li> <p>Under the UNLOCKED field, press the CLAIM button to initiate your token claim.</p> </li> <li> <p>You will see two fields, the BALANCE field and CLAIM field. The first shows the current amount of tokens in your account balance, and the other field lets you enter the amount of tokens you wish to claim.</p> </li> <li> <p>Under the CLAIM field, enter the amount of XPLL you wish to claim. This number cannot exceed the amount in the UNLOCKED field.</p> </li> <li> <p>Press the NEXT button at the bottom once you are satisfied with the amount entered.</p> </li> <li> <p>The following fields will appear:</p> <ul> <li>Nonce - will be automatically populated for you.</li> <li>Max Base Fee per Gas - The minimum fee is 8 XPLL, and this field will be automatically populated for you.</li> <li>Priority Fee per Gas - the priority of your transaction. The minimum fee is 0.</li> <li>Gas Limit - will be automatically populated for you.</li> </ul> <p> </p> </li> <li> <p>Once you are satisfied with the populated fields, press NEXT at the bottom.</p> </li> <li> <p>Preview the summary of the transaction, then press CONFIRM to continue, or CANCEL to make edits.</p> </li> <li> <p>The status of the token deposit will be shown as PENDING. When it is validated by the network, a SUCCESS will be shown under its status tab.</p> </li> <li> <p>The claimed tokens have now successfully been transferred to your account balance.</p> </li> </ol> <p>Watch the video tutorial to claim your vested tokens here.</p>","tags":["Xperience","explorer","lockup contract"]},{"location":"for_users/web_wallet/lockup_contract/#faq","title":"FAQ","text":"","tags":["Xperience","explorer","lockup contract"]},{"location":"for_users/web_wallet/lockup_contract/#do-i-need-to-wait-for-the-full-vesting-period-before-being-able-to-claim-the-locked-xpll","title":"Do I need to wait for the full vesting period before being able to claim the locked XPLL?","text":"<p>A set amount of XPLL will be unlocked after a set period of time, and will be displayed in the UNLOCKED field. You may choose to claim after the end of each duration, although gas fees will have to be paid each time. You can also choose to accumulate the unlocked XPLL and claim them later in one transaction.</p>","tags":["Xperience","explorer","lockup contract"]},{"location":"for_users/web_wallet/staking/","title":"Staking XPLL","text":"<p>You can stake XPLL with network validators to help secure the blockchain and earn rewards in the meantime. Follow the steps below to stake XPLL tokens with your ParallelChain account. You can also watch the video tutorial here.</p>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#logging-in-your-wallet","title":"Logging in Your Wallet","text":"<ol> <li>Access the ParallelChain Explorer, or click on the EXPLORER button on the ParallelChain homepage.</li> <li>To log in, click on the round icon on the top right hand corner of the explorer page and enter your password.</li> <li>Press the LOGIN button.</li> <li>If you do not remember your password, you can choose to log in with your recovery key. Once you have access to your account, you should set a new password through your wallet settings.</li> <li>Once you are verified, you can access your wallet account.</li> </ol>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#depositing-your-xpll","title":"Depositing Your XPLL","text":"","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#step-1-select-a-validator","title":"Step 1: Select a validator","text":"<ol> <li>Click the STAKE button which is located beside the SEND button.</li> <li>You will see the list of validator pools you can stake in.</li> <li>Choose from the list, or search for a specific validator via the search bar at the top labelled SEARCH OPERATOR ADDRESS.</li> </ol>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#step-2-deposit-xpll","title":"Step 2: Deposit XPLL","text":"","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#through-your-account","title":"Through Your Account","text":"<ol> <li> <p>Once you have selected your desired validator, the details of the validator pool will be displayed.</p> </li> <li> <p>Selecting the drop-down arrow under the POOL NAME field reveals the OPERATOR field, POOL STAKE field, and COMMISSION FEE field.</p> <ul> <li>OPERATOR - the validator's address is displayed here.</li> <li>POOL STAKE - the amount of XPLL staked with the validator is displayed here.</li> <li>COMMISSION FEE - the number displayed is the percentage of your rewards the validator will take as a commission fee.</li> </ul> </li> <li> <p>To deposit your XPLL with the validator, enter the desired amount in the DEPOSIT field.</p> </li> <li>If you would like to auto-stake your rewards, toggle the AUTO STAKE REWARDS field on.</li> </ol>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#through-your-lock-up-contract","title":"Through Your Lock-Up Contract","text":"<ol> <li> <p>Once you have selected your desired validator, the details of the validator pool will be displayed.</p> <ul> <li>LOCK-UP CONTRACT (XPLL) field and LOCKED field, your tokens that are still vested are shown here.</li> <li>Selecting the drop-down arrow under the POOL NAME field reveals the OPERATOR field, POOL STAKE field, and COMMISSION FEE field.</li> <li>OPERATOR field, the validator**s address is displayed here.</li> <li>COMMISSION FEE field, the number displayed is the percentage of your rewards the validator will take as a commission fee.</li> <li>COMMISSION FEE field, the number displayed is the percentage of your rewards the validator will take as a commission fee.</li> </ul> </li> <li> <p>When you deposit your XPLL with the lock-up contract, the amount is automatically filled for you in the DEPOSIT field.</p> </li> <li>If you would like to auto-stake your rewards, toggle the AUTO STAKE REWARDS field on.</li> </ol>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#step-3-confirm-your-transaction","title":"Step 3: Confirm Your Transaction","text":"<ol> <li> <p>The following fields will appear:</p> <ul> <li>Nonce - This field will be automatically populated for you.</li> <li>Max Base Fee per Gas - This field will be automatically populated for you based on the current Base Fee per Gas of the network.</li> <li>Priority Fee per Gas - This determines the priority of your transaction, and the minimum fee is 0 XPLL.</li> <li>Gas Limit - This field will be automatically populated for you.</li> </ul> </li> <li> <p>Once you are satisfied with the populated fields, press NEXT at the bottom.</p> </li> <li>Preview the summary of the transaction, then press CONFIRM to continue, or CANCEL to make edits</li> <li>The status of the token deposit will be shown as PENDING. When it is validated by the network, a SUCCESS will be shown under its status tab.</li> <li>Your XPLL has now been successfully deposited with the validator. You can create more than one deposit by repeating the process under different validators.</li> <li>To start earning XPLL from staking, follow the instructions under Stake Your XPLL below.</li> </ol> <p>Watch the video tutorial to learn how to deposit XPLL to the staking wallet here.</p>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#staking-your-xpll","title":"Staking Your XPLL","text":"<p>You can stake XPLL which you have deposited with validators to earn rewards.</p>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#step-1-navigate-to-your-chosen-validator","title":"Step 1: Navigate To Your Chosen Validator","text":"<ol> <li>On the main page, select the STAKES tab which is located beside the TRANSACTIONS tab. Then select the pool which you wish to top up XPLL.</li> <li> <p>The pool information will be shown, along with fields relevant to you. This includes:</p> <ul> <li>DEPOSIT - the amount of XPLL you have deposited with the validator.</li> <li>TENTATIVE STAKE - the balance you have in the pool at this moment which will become part of the current stake in the future.</li> <li>CURRENT STAKE - the balance in the pool which has become part of the current validator set, and is now earning rewards.</li> <li>If you would like to auto-stake your rewards, toggle the AUTO STAKE REWARDS field on.</li> </ul> <p></p> </li> <li> <p>To stake XPLL, tap on the arrow beside the TENTATIVE STAKE field.</p> </li> </ol>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#step-2-stake-xpll","title":"Step 2: Stake XPLL","text":"","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#from-your-account","title":"From Your Account","text":"<ol> <li> <p>The details of the validator pool will be displayed as shown:</p> <ul> <li> <p>Selecting the drop-down arrow under the POOL NAME:</p> <ul> <li>OPERATOR - the validator's address.</li> <li>POOL STAKE - the amount of XPLL staked with the validator.</li> <li>COMMISSION FEE - the percentage of your rewards the validator will take as a commission fee.</li> </ul> </li> <li> <p>Your deposited XPLL will be shown in the DEPOSIT field.</p> </li> </ul> </li> <li> <p>Create your initial stake with the validator by entering the amount of XPLL you wish to stake in the STAKE MAX field. The number cannot exceed the amount of XPLL you have deposited.</p> </li> <li>If you have an existing stake with the validator, you have the option to stake more XPLL or unstake them with the STAKE and UNSTAKE buttons respectively.</li> <li>To add more staked XPLL, select the STAKE button. Enter the amount of XPLL you wish to stake in the STAKE MAX field. The number cannot exceed the amount of XPLL you have deposited.</li> <li>Press NEXT once you are comfortable with the amount.</li> </ol>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#from-your-lock-up-contract","title":"From Your Lock-Up Contract","text":"<ol> <li> <p>The details of the validator pool will be displayed as shown:</p> <ul> <li>LOCK-UP CONTRACT (XPLL)/LOCKED - your tokens that are still vested.</li> <li> <p>Selecting the drop-down arrow under the POOL NAME:</p> <ul> <li>OPERATOR - the validator's address.</li> <li>POOL STAKE - the amount of XPLL staked with the validator.</li> <li>COMMISSION FEE - the percentage of your rewards the validator will take as a commission fee.</li> </ul> </li> <li> <p>Your deposited XPLL will be shown in the DEPOSIT field.</p> </li> </ul> </li> <li> <p>Create your initial stake with the validator. The amount is automatically filled for you in the STAKE MAX field.</p> </li> <li>If you have an existing stake with the validator, you have the option to stake more XPLL or unstake them with the STAKE and UNSTAKE buttons respectively.</li> <li>To add more staked XPLL, select the STAKE button. If you are staking with the validator through a lock-up contract, the amount is automatically filled for you in the STAKE MAX field.</li> <li>Press NEXT to continue.</li> </ol>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#step-3-confirm-your-transaction_1","title":"Step 3: Confirm Your Transaction","text":"<ol> <li> <p>The following fields will appear:</p> <ul> <li>Nonce - This field will be automatically populated for you.</li> <li>Max Base Fee per Gas- This field will be automatically populated for you based on the current Base Fee per Gas of the network.</li> <li>Priority Fee per Gas- This determines the priority of your transaction, and the minimum fee is 0 XPLL.</li> <li>Gas Limit- This field will be automatically populated for you.</li> </ul> </li> <li> <p>Once you are satisfied with the populated fields, press NEXT at the bottom.</p> </li> <li>Preview the summary of the transaction, then press CONFIRM to continue, or CANCEL to make edits.</li> <li>The status of the token deposit will be shown as PENDING. When it is validated by the network, a SUCCESS will be shown under its status tab. </li> </ol> <p>Note</p> <p>Due to the network state when your transaction gets included, the actual amount may differ slightly from your desired amount.</p> <p>Watch the video tutorial on how to stake your XPLL here.</p>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#topping-up-your-stake","title":"Topping Up Your Stake","text":"","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#step-1-navigate-to-your-chosen-validator_1","title":"Step 1: Navigate To Your Chosen Validator","text":"<ol> <li>On the main page, select the STAKES tab which is located beside the TRANSACTIONS tab. Then select the pool which you wish to top up XPLL.</li> <li> <p>The pool information will be shown, along with fields relevant to you. This includes:</p> <ul> <li>DEPOSIT - the amount of XPLL you have deposited with the validator.</li> <li>TENTATIVE STAKE - the balance you have in the pool at this moment which will become part of the current stake in the future.</li> <li>CURRENT STAKE - the balance in the pool which has become part of the current validator set, and is now earning rewards.</li> <li>If you would like to auto-stake your rewards, toggle the AUTO STAKE REWARDS field on.</li> </ul> <p> 3. To top up XPLL, tap on the arrow beside the DEPOSIT field</p> </li> </ol>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#step-2-top-up-your-stake-through-your-account","title":"Step 2: Top-up Your Stake Through Your Account","text":"<ol> <li> <p>Once you have selected your desired validator, the details of the validator pool will be displayed as shown:</p> <ul> <li> <p>Selecting the drop-down arrow under the POOL NAME:</p> <ul> <li>OPERATOR - the validator's address.</li> <li>POOL STAKE - the amount of XPLL staked with the validator.</li> <li>COMMISSION FEE - the percentage of your rewards the validator will take as a commission fee.</li> </ul> </li> <li> <p>Your deposited XPLL will be shown in the DEPOSIT field.</p> </li> </ul> <p></p> </li> <li> <p>Select TOP-UP to deposit more XPLL to your validator deposit.</p> </li> <li>The TOP-UP field will appear, and you can enter the amount you wish to top-up. The amount cannot exceed your account balance.</li> <li>Click NEXT to continue.</li> </ol>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#step-3-confirm-your-transaction_2","title":"Step 3: Confirm Your Transaction","text":"<ol> <li> <p>The following fields will appear:</p> <ul> <li>Nonce - This field will be automatically populated for you.</li> <li>Max Base Fee per Gas- This field will be automatically populated for you based on the current Base Fee per Gas of the network.</li> <li>Priority Fee per Gas- This determines the priority of your transaction, and the minimum fee is 0 XPLL.</li> <li>Gas Limit- This field will be automatically populated for you.</li> </ul> </li> <li> <p>Once you are satisfied with the populated fields, press NEXT at the bottom.</p> </li> <li>Preview the summary of the transaction, then press CONFIRM to continue, or CANCEL to make edits.</li> <li>The status of the token deposit top up will be shown as PENDING. When it is validated by the network, a SUCCESS will be shown under its status tab.</li> </ol> <p>Watch the video tutorial on how to top up your XPLL here.</p>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#withdrawing-your-stakes","title":"Withdrawing Your Stakes","text":"","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#step-1-navigate-to-your-chosen-validator_2","title":"Step 1: Navigate To Your Chosen Validator","text":"<ol> <li>On the main page, select the STAKES tab which is located beside the TRANSACTIONS tab. Then select the pool which you wish to withdraw XPLL.</li> <li> <p>The pool information will be shown, along with fields relevant to you. This includes:</p> <ul> <li>DEPOSIT - the amount of XPLL you have deposited with the validator.</li> <li>TENTATIVE STAKE - the balance you have in the pool at this moment which will become part of the current stake in the future.</li> <li>CURRENT STAKE - the balance in the pool which has become part of the current validator set, and is now earning rewards.</li> <li>If you would like to auto-stake your rewards, toggle the AUTO STAKE REWARDS field on.</li> </ul> <p> </p> </li> <li> <p>To withdraw XPLL, tap on the arrow beside the DEPOSIT field.</p> </li> </ol>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#step-2-withdraw-stakes","title":"Step 2: Withdraw Stakes","text":"","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#to-your-account","title":"To Your Account","text":"<ol> <li> <p>The details of the validator pool will be displayed as shown:</p> <ul> <li> <p>Selecting the drop-down arrow under the POOL NAME:</p> <ul> <li>OPERATOR - the validator's address.</li> <li>POOL STAKE - the amount of XPLL staked with the validator.</li> <li>COMMISSION FEE - the percentage of your rewards the validator will take as a commission fee.</li> </ul> </li> <li> <p>Your deposited XPLL will be shown in the DEPOSIT field.</p> </li> </ul> <p></p> </li> <li> <p>Select WITHDRAW to withdraw XPLL from your validator deposit.</p> </li> <li>The WITHDRAW MAX field will appear, and you can enter the amount you wish to withdraw. The amount cannot exceed the current amount deposited with the validator.</li> </ol>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#to-your-lock-up-contract","title":"To Your Lock-Up Contract","text":"<ol> <li> <p>The details of the validator pool will be displayed as shown:</p> <ul> <li>LOCK-UP CONTRACT (XPLL)/LOCKED - your tokens that are still vested.</li> <li> <p>Selecting the drop-down arrow under the POOL NAME:</p> <ul> <li>OPERATOR - the validator's address.</li> <li>POOL STAKE - the amount of XPLL staked with the validator.</li> <li>COMMISSION FEE - the percentage of your rewards the validator will take as a commission fee.</li> </ul> </li> <li> <p>Your deposited XPLL will be shown in the DEPOSIT field.</p> </li> </ul> </li> <li> <p>Select WITHDRAW to withdraw XPLL from your validator deposit.</p> </li> <li>If you are withdrawing from the validator to a lock-up contract, the amount is automatically filled for you in the WITHDRAW MAX field. According to the period when you withdraw your XPLL, the withdrawal may be split between your lock-up contract's locked and unlocked tokens.</li> <li>Press NEXT to continue</li> </ol>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#step-3-confirm-your-transaction_3","title":"Step 3: Confirm Your Transaction","text":"<ol> <li> <p>The following fields will appear:</p> <ul> <li>Nonce - This field will be automatically populated for you.</li> <li>Max Base Fee per Gas- This field will be automatically populated for you based on the current Base Fee per Gas of the network.</li> <li>Priority Fee per Gas- This determines the priority of your transaction, and the minimum fee is 0 XPLL.</li> <li>Gas Limit- This field will be automatically populated for you.</li> </ul> </li> <li> <p>Once you are satisfied with the populated fields, press NEXT at the bottom</p> </li> <li>Preview the summary of the transaction, then press CONFIRM to continue, or CANCEL to make edits</li> <li>The status of the token withdrawal will be shown as PENDING. When it is validated by the network, a SUCCESS will be shown under its status tab. </li> </ol> <p>Note</p> <p>Due to the network state when your transaction gets included, the actual amount may differ slightly from your desired amount.</p> <p>Watch the video tutorial to withdraw your XPLL here.</p>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#unstaking-your-xpll","title":"Unstaking Your XPLL","text":"","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#step-1-navigate-to-your-chosen-validator_3","title":"Step 1: Navigate To Your Chosen Validator","text":"<ol> <li>On the main page, select the STAKES tab which is located beside the TRANSACTIONS tab. Then select the pool which you wish to top up XPLL.</li> <li> <p>The pool information will be shown, along with fields relevant to you. This includes:</p> <ul> <li>DEPOSIT - the amount of XPLL you have deposited with the validator.</li> <li>TENTATIVE STAKE - the balance you have in the pool at this moment which will become part of the current stake in the future.</li> <li>CURRENT STAKE - the balance in the pool which has become part of the current validator set, and is now earning rewards.</li> <li>If you would like to auto-stake your rewards, toggle the AUTO STAKE REWARDS field on.</li> </ul> <p></p> </li> <li> <p>To unstake XPLL, tap on the arrow beside the TENTATIVE STAKEfield.</p> </li> </ol>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#step-2-unstake-xpll","title":"Step 2: Unstake XPLL","text":"","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#to-your-account_1","title":"To Your Account","text":"<ol> <li> <p>The details of the validator pool will be displayed as shown:</p> <ul> <li> <p>Selecting the drop-down arrow under the POOL NAME:</p> <ul> <li>OPERATOR - the validator's address.</li> <li>POOL STAKE - the amount of XPLL staked with the validator.</li> <li>COMMISSION FEE - the percentage of your rewards the validator will take as a commission fee.</li> </ul> </li> <li> <p>Your deposited XPLL will be shown in the DEPOSIT field.</p> </li> </ul> </li> <li> <p>You have the option to add more staked XPLL or unstake them with the STAKE and UNSTAKE buttons respectively.</p> </li> <li>To unstake XPLL, select the UNSTAKE button. Enter the amount of XPLL you wish to unstake in the UNSTAKE MAX field. The number cannot exceed the amount of XPLL you have staked.</li> <li>Press NEXT once you are comfortable with the amount.</li> </ol>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#to-your-lock-up-contract_1","title":"To Your Lock-Up Contract","text":"<ol> <li> <p>The details of the validator pool will be displayed as shown:</p> <ul> <li>LOCK-UP CONTRACT (XPLL)/LOCKED - your tokens that are still vested.</li> <li> <p>Selecting the drop-down arrow under the POOL NAME:</p> <ul> <li>OPERATOR - the validator's address.</li> <li>POOL STAKE - the amount of XPLL staked with the validator.</li> <li>COMMISSION FEE - the percentage of your rewards the validator will take as a commission fee.</li> </ul> </li> <li> <p>Your deposited XPLL will be shown in the DEPOSIT field.</p> </li> </ul> </li> <li> <p>You have the option to add more staked XPLL or unstake them with the STAKE and UNSTAKE buttons respectively.</p> </li> <li>To unstake XPLL, select the UNSTAKE button. If you are unstaking from the validator through a lock-up contract, the amount is automatically filled for you in the UNSTAKE MAX field.</li> <li>Press NEXT to continue.</li> </ol>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#step-3-confirm-your-transaction_4","title":"Step 3: Confirm Your Transaction","text":"<ol> <li> <p>The following fields will appear:</p> <ul> <li>Nonce - This field will be automatically populated for you.</li> <li>Max Base Fee per Gas- This field will be automatically populated for you based on the current Base Fee per Gas of the network.</li> <li>Priority Fee per Gas- This determines the priority of your transaction, and the minimum fee is 0 XPLL.</li> <li>Gas Limit- This field will be automatically populated for you.</li> </ul> </li> <li> <p>Once you are satisfied with the populated fields, press NEXT at the bottom.</p> </li> <li>Preview the summary of the transaction, then press CONFIRM to continue, or CANCEL to make edits.</li> <li>The status of the token deposit will be shown as PENDING. When it is validated by the network, a SUCCESS will be shown under its status tab.</li> </ol> <p>Note</p> <p>Due to the network state when your transaction gets included, the actual amount may differ slightly from your desired amount.</p> <p>Watch the video tutorial to unstake your XPLL here.</p>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#faq","title":"FAQ","text":"","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#why-am-i-not-able-to-stake-xpll-tokens","title":"Why am I not able to stake XPLL tokens?","text":"<p>You will need to retain a certain amount of XPLL in your account balance to pay for transaction fees. Ensure that you have reserved a small amount of XPLL tokens to pay for the gas fee of your deposit, stake, or unstake XPLL tokens.</p>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#how-do-i-know-which-validator-to-stake-with","title":"How do I know which validator to stake with?","text":"<p>The validators securing ParallelChain Mainnet are trusted participants which are required to stake a significant number of XPLL. You may check the yield and commission fee of each validator by tapping on the drop-down arrow of the Operator field.</p>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#how-long-is-the-unstaking-period","title":"How long is the unstaking period?","text":"<p>The staking duration is measured by epochs. If you stake and unstake within the same epoch, the waiting time is considerably shorter. If the staking and unstaking are not within the same epoch, you will need to wait at least for another two epochs before unstaking.</p>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#how-long-is-an-epoch","title":"How long is an Epoch?","text":"<p>One full epoch lasts approximately one day before it enters the next epoch. The epoch itself is a protocol-defined period for measuring performance of operators on the network.</p>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#how-do-i-withdraw-my-staking-rewards","title":"How do I withdraw my staking rewards?","text":"<p>You can withdraw the rewards you have earned from staking by unstaking them to your Token Deposit. Additionally, you may toggle the AUTO STAKE REWARDS to avoid the process of unstaking your rewards. From there, you can then withdraw the amount to your wallet. Please refer to the section of Unstaking Your XPLL and Withdrawing Your Stakes for the required steps.</p>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#can-i-move-my-staked-xpll-to-another-validator","title":"Can I move my staked XPLL to another validator?","text":"<p>Yes, you can. You will need to unstake your XPLL tokens, withdraw them to the Token Deposit, then back to your wallet. You can then transfer those tokens to a Token Deposit with another validator before staking your tokens with them. Please refer to the sections above to move your XPLL to another validator.</p>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/staking/#the-status-is-still-showing-pending-why-is-my-transaction-not-confirmed-yet","title":"The status is still showing PENDING. Why is my transaction not confirmed yet?","text":"<p>Transactions are prioritised by the amount of Priority Fee per Gas paid, and lower priority transactions may need more time to be confirmed. You may choose to pay a higher Priority Fee during peak periods for a faster transaction, or you may check your wallet address on the blockchain explorer to monitor its transaction status.</p>","tags":["Xperience","explorer","staking"]},{"location":"for_users/web_wallet/transfer_tokens/","title":"Transferring Tokens","text":"<p>Sending and receiving assets with digital wallets is a keystone of any blockchain's decentralised infrastructure. Follow the steps below to send and receive XPLL tokens with your ParallelChain account. You can also watch the video tutorials to send XPLL tokens here.</p>","tags":["Xperience","explorer","xpll"]},{"location":"for_users/web_wallet/transfer_tokens/#sending-xpll","title":"Sending XPLL","text":"","tags":["Xperience","explorer","xpll"]},{"location":"for_users/web_wallet/transfer_tokens/#step-1-login-your-wallet","title":"Step 1: Login Your Wallet","text":"<ol> <li>Access the blockchain explorer via explorer.parallelchain.io, or click on the EXPLORER button on the ParallelChain homepage.</li> <li>To log in, click on the round icon on the top right hand corner of the webpage and enter your password.</li> <li>Press the VERIFY button.</li> <li>If you do not remember your password, you can choose to log in with your recovery key. Once you have access to your account, you should set a new password through your wallet settings.</li> <li>Once you are verified, you can access your wallet account.</li> </ol>","tags":["Xperience","explorer","xpll"]},{"location":"for_users/web_wallet/transfer_tokens/#step-2-send-xpll-to-another-address","title":"Step 2: Send XPLL to Another Address","text":"<ol> <li> <p>Click the SEND button below the display that shows your XPLL balance.</p> <p> </p> </li> <li> <p>Enter the address that you want to send XPLL tokens to in the To Address field. If you are transferring tokens between your own accounts internally, you can copy the address of the receiving account by clicking the COPY icon beside its address.</p> </li> <li>Next, go back to the wallet's main interface and press the SEND button located beside the STAKE button.</li> <li>Paste the receiving address in the To Address field, and enter the amount of XPLL tokens you would like to send in the Send field. The amount must not be a negative number, and it cannot exceed the amount of tokens you currently have. Press NEXT once you have entered the amount.</li> <li>The following fields will appear:<ul> <li>Nonce: This field will be automatically populated for you.</li> <li>Max Base Fee per Gas: This field will be automatically populated for you based on the current Base Fee per Gas of the network.</li> <li>Priority Fee per Gas: This determines the priority of your transaction, and the minimum fee is 0 XPLL.</li> <li>Gas Limit: This field will be automatically populated for you.</li> </ul> </li> <li>Once you are satisfied with the populated fields, press NEXT at the bottom.</li> </ol>","tags":["Xperience","explorer","xpll"]},{"location":"for_users/web_wallet/transfer_tokens/#step-3-confirm-your-transaction","title":"Step 3: Confirm Your Transaction","text":"<ol> <li>Preview the summary of the transaction, then press CONFIRM to continue, or CANCEL to make edits.</li> <li>The status of the token deposit will be shown as PENDING. When it is validated by the network, SUCCESS will be shown under its status tab.</li> <li>You may review your transaction details again by selecting the TRANSACTIONS tab on the main page of the account, then select the listed transaction.</li> <li>Watch the video tutorial to send XPLL tokens here.</li> </ol>","tags":["Xperience","explorer","xpll"]},{"location":"for_users/web_wallet/transfer_tokens/#receiving-xpll","title":"Receiving XPLL","text":"","tags":["Xperience","explorer","xpll"]},{"location":"for_users/web_wallet/transfer_tokens/#step-1-share-your-account-address","title":"Step 1: Share Your Account Address","text":"<ul> <li>To share your account address with others, tap on the Copy icon beside your wallet address.</li> <li>Send it to the sender through a secure text messaging application.</li> <li>The sender should paste your address in the To Address field in their ParallelChain wallet.</li> </ul>","tags":["Xperience","explorer","xpll"]},{"location":"for_users/web_wallet/transfer_tokens/#step-2-receive-your-xpll","title":"Step 2: Receive Your XPLL","text":"<ul> <li>After the sender has confirmed the transaction, be patient as the transaction is being validated by the network.</li> <li>Once the sender's transaction is confirmed, your wallet balance will be automatically updated.</li> </ul>","tags":["Xperience","explorer","xpll"]},{"location":"for_users/web_wallet/transfer_tokens/#faq","title":"FAQ","text":"","tags":["Xperience","explorer","xpll"]},{"location":"for_users/web_wallet/transfer_tokens/#i-have-not-received-my-xpll-where-can-i-check-the-transaction-status","title":"I have not received my XPLL. Where can I check the transaction status?","text":"<p>To check the status of your transaction, you can access the ParallelChain Explorer and key in your wallet address. It will display the status and amount being sent. If you are the transaction initiator, you can refer to the status on your wallet's ACTIVITY tab.</p>","tags":["Xperience","explorer","xpll"]},{"location":"for_users/web_wallet/transfer_tokens/#can-i-cancel-or-refund-transactions","title":"Can I cancel or refund transactions?","text":"<p>No, once a transaction request has been made, it cannot be cancelled.</p>","tags":["Xperience","explorer","xpll"]},{"location":"for_users/xperience_browser_extension/create_account/","title":"Creating and Managing Your Account","text":"<p>Note</p> <p>This process is the same on Xperience Browser Extension as it is on ParallelChain Explorer. </p> <p>Xperience Browser Extension is browser extension of your ParellelChain Explorer Wallet.</p> <p>To conduct transactions on ParallelChain Mainnet you will first need to create an account on the blockchain to access the network. Accounts are free to create, and they can be set up through Xperience Browser Extension\u2014or through the good old ParallelChain Explorer.</p> <p>The blockchain account you create on ParallelChain is non-custodial, which means only you have control and access to it. You must store your recovery key securely and properly to avoid losing access to your assets. There is no way to retrieve it if it is lost. </p> <p>Learn how to create and manage your ParallelChain account using Xperience Browser Extension with the steps below. </p>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#installing-xperience-browser-exension","title":"Installing Xperience Browser Exension","text":"<p>The extension currently only works on Chrome. Chrome user can install the extension via the Chrome Web Store. </p> <p>If necessary, refer to these instructions on installing Chrome extensions.</p>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#registering-for-a-new-wallet","title":"Registering for a New Wallet","text":"","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#getting-your-recovery-key","title":"Getting Your Recovery Key","text":"<ol> <li> <p>Open Xperience Browser Extension by clicking on its icon next to your browser address bar.</p> </li> <li> <p>Click Register.</p> </li> <li> <p>Your 12-word recover key will be generated automatically. Copy your recovery key by clicking COPY AS TEXT and paste it in a secure document, or by writing down the words in the exact order in which they appear.</p> </li> <li> <p>Store your recovery key in a secure location.</p> </li> <li> <p>Click Next.</p> </li> </ol>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#verifying-your-recovery-key","title":"Verifying Your Recovery Key","text":"<ol> <li> <p>You will be prompted to fill in some missing words in your recovery key. Refer to your recovery key to enter all the missing words in the blanks.</p> </li> <li> <p>Click Next.</p> </li> <li> <p>If an error message appears, refer to your recovery key again and check if you have entered the correct words.</p> </li> </ol>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#creating-your-password","title":"Creating Your Password","text":"<ol> <li> <p>Create a password for your wallet and enter it in the Password field. Your password can contain any characters, but it must satisfy the following conditions:</p> <ul> <li>at least 8 characters long, </li> <li>at least 1 uppercase letter,</li> <li>at least 1 lowercase letter, </li> <li>at least 1 number.</li> </ul> </li> <li> <p>Enter your password again in the Confirm Password field. If you receive a <code>Passwords do not match</code> error, re-enter your password and check that both your entries are the same.</p> <p>Note</p> <p>This password is only limited to the wallet access on the particular device you are registering your account on, and it cannot be accessed from another device.</p> </li> <li> <p>Click REGISTER. Congratulations! Your ParallelChain account has now been created.</p> </li> <li> <p>You will be prompted to enter your password again to log in to your wallet.</p> </li> </ol>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#importing-an-existing-wallet","title":"Importing an Existing Wallet","text":"<ol> <li> <p>Open Xperience Browser Extension by clicking on the extension icon next to your browser address bar.</p> </li> <li> <p>Click IMPORT EXISTING WALLET.</p> </li> <li> <p>Enter your 12-word recovery key that you had stored securely when you first created that wallet.</p> </li> <li> <p>Click Next.</p> </li> </ol> <p>You will be prompted to create a password for your wallet. You can follow the instructions here.</p> <p>Note</p> <p>Importing your wallet only recovers accounts associated with the recovery key. Refer to the steps in Exporting Account and Importing Account to export and import individual accounts.</p>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#logging-into-your-wallet","title":"Logging into Your Wallet","text":"<ol> <li> <p>Open Xperience Browser Extension by clicking on the extension icon next to your browser address bar.</p> </li> <li> <p>Enter your password and click VERIFY. You can now access your wallet.</p> </li> </ol> <p>If you do not remember your password, you can reset your password with your recovery key:</p> <ol> <li> <p>Start by clicking FORGOT PASSWORD.</p> </li> <li> <p>Enter the 12-word recovery key that you had stored securely when you first created your wallet. Click NEXT.</p> </li> <li> <p>Follow the instruction in Create Your Password to set up your new password.</p> </li> </ol>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#configuring-your-security-and-login","title":"Configuring Your Security and Login","text":"","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#viewing-your-recovery-key","title":"Viewing Your Recovery Key","text":"<ol> <li> <p>Click the icon with three dots on the top-right corner of the extension.</p> </li> <li> <p>Click Security &amp; Login.</p> </li> <li> <p>Enter your password and click VERIFY.</p> <p>Note</p> <p>If you do not remember your password, you can log in with your recovery key.</p> <ul> <li>Click VERIFY WITH RECOVERY KEY.</li> <li>Enter your 12-word recovery key and click Next.</li> </ul> </li> <li> <p>Click View Recovery Key. You will see your 12-word recovery key.</p> </li> </ol>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#changing-your-password","title":"Changing Your Password","text":"<ol> <li> <p>Click the icon with the three dots on the top-right corner of the extension.</p> </li> <li> <p>Click Security &amp; Login.</p> </li> <li> <p>Enter your password and click VERIFY.</p> <p>Note</p> <p>If you do not remember your password, you can reset your password with your recovery key. </p> <ul> <li>Click VERIFY WITH RECOVERY KEY.</li> <li>Enter your 12-word recovery key. Click Next and Change Password.</li> </ul> </li> <li> <p>Create a new password for your wallet and enter it in the Password field. Your password can contain any characters, but it must satisfy the following conditions:</p> <ul> <li>at least 8 characters long, </li> <li>at least 1 uppercase letter,</li> <li>at least 1 lowercase letter, </li> <li>at least 1 number.</li> </ul> </li> <li> <p>Enter your password again in the Confirm Password field. If you receive a <code>Passwords do not match</code> error, re-enter your password and check that both your entries are the same.</p> <p>Note</p> <p>This password is only limited to the wallet access on the particular device you are registering your account on, and it cannot be accessed from another device.</p> </li> <li> <p>Click SAVE CHANGES. Your password has now been changed.</p> </li> <li> <p>You will be prompted to enter your password again to log in to your wallet.</p> </li> </ol>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#erasing-wallet-from-device","title":"Erasing Wallet from Device","text":"<ol> <li> <p>Click the icon with three dots on the top-right corner of the extension.</p> </li> <li> <p>Click Security &amp; Login.</p> </li> <li> <p>Enter your password and click VERIFY.</p> <p>Note</p> <p>If you do not remember your password, you can reset your password with your recovery key. </p> <ul> <li>Click VERIFY WITH RECOVERY KEY.</li> <li>Enter your 12-word recovery key. Click Next and Change Password.</li> </ul> </li> <li> <p>Click ERASE WALLET FROM DEVICE. You will be prompted with a note that the action cannot be undone.</p> </li> <li> <p>Confirm by clicking ERASE to remove your wallet data from your device or click CANCEL to return to the previous screen.</p> </li> </ol>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#exporting-account","title":"Exporting Account","text":"","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#as-public-and-private-keys","title":"As Public and Private Keys","text":"<ol> <li>Click the drop-down arrow right beside your wallet address.</li> <li>Your wallet address acts as your public key. Click the copy icon next to your public key to copy it and save it in a secure location.</li> <li>Click on the key icon to view your private key.</li> <li>Click on the copy icon next to your private key to copy it and save it in a secure location.</li> </ol>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#as-a-json-file","title":"As a JSON File","text":"<p>Alternatively, you can download the keypair of your current account in a JSON file.   </p> <ol> <li>Click the drop-down arrow right beside your wallet address.</li> <li>Click the download icon beside your wallet address to start the download.</li> <li>Store the JSON file securely. You can open the file with any text editor, like Notepad or Microsoft Word.</li> </ol> <p>Note</p> <p>If you wish to recover your account on another wallet, you can do so by importing your accounts. Refer to the steps in Importing Account.</p>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#importing-account","title":"Importing Account","text":"","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#using-public-and-private-keys","title":"Using Public and Private Keys","text":"<ol> <li>Click the drop-down arrow right beside your wallet address.</li> <li>Click IMPORT.</li> <li>Enter your public key in the Public Address field.</li> <li>Enter your private key in the Private Key field.</li> <li> <p>Enter your desired account name in the Account Name field.</p> <p>Note</p> <p>If you are not sure where to find your public and private keys, refer to Exporting Account as Public &amp; Private Keys.</p> </li> <li> <p>Click IMPORT. You have successfully imported your account.</p> </li> </ol>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#using-a-json-file","title":"Using a JSON File","text":"<ol> <li>Click the drop-down arrow right beside your wallet address.</li> <li>Click IMPORT. </li> <li> <p>Click IMPORT WITH FILE and select the appropriate JSON file.</p> <p>Note</p> <p>If you are not sure how to export your JSON file, refer to Exporting Account as a JSON File.</p> </li> <li> <p>Click IMPORT. You have successfully imported your account.</p> </li> </ol>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#locking-your-wallet","title":"Locking Your Wallet","text":"<ol> <li>Click the icon with three dots on the top-right corner of the extension.</li> <li>Click on LOCK WALLET. </li> <li>Your wallet is now locked. You will be prompted to enter your password again to log in to your wallet.</li> </ol>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#faq","title":"FAQ","text":"","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#is-the-wallet-in-xperience-browser-extension-the-same-as-the-wallet-in-parallelchain-explorer","title":"Is the wallet in Xperience Browser Extension the same as the wallet in ParallelChain Explorer?","text":"<p>Yes, they are the same. You can access your wallet through either Xperience Browser Extension or ParallelChain Explorer.</p>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#is-my-xperience-browser-extension-the-same-as-my-parallelchain-account","title":"Is my Xperience Browser Extension the same as my ParallelChain account?","text":"<p>No, they are not the same. Your ParallelChain account is the keypair registered on the ParallelChain Mainnet, and the Xperience browser extension is simply a platform that connects you to your ParallelChain account. You can access your ParallelChain account as long as you have your keypair, even if you lose the device the Xperience Browser Extension is installed on.</p>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#can-i-send-xpll-tokens-to-other-blockchains-like-ethereum","title":"Can I send XPLL tokens to other blockchains like Ethereum?","text":"<p>No, you cannot send XPLL tokens to other blockchains at the moment. XPLL and other PRFC tokens are currently only compatible with the ParallelChain Mainnet network, and sending your tokens to other network addresses will lose your tokens.</p>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#what-happens-if-i-lose-both-my-recovery-key-and-password","title":"What happens if I lose both my recovery key and password?","text":"<p>Xperience is a non-custodial wallet that only you have access to. If you lose your recovery key and password, you will lose access to your wallet. We recommend that you write down your recovery key and store it in a secure place.</p> <p>If you have lost access to your existing wallet, you can opt to register for a new wallet by clearing the cache of your current browser, and then refreshing the page. Please check with your selected browser to find out how to clear your browser cache. After that, register for a new wallet by following the steps under Register for a New Wallet.</p> <p>If you have exported your public and private keys before, you can then recover access to your assets by importing your old account with its public and private keys. For more details, follow the steps under Exporting Account and Importing Account.</p>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/create_account/#where-can-i-seek-support-or-report-bugs","title":"Where can I seek support or report bugs?","text":"<p>You can visit ParallelChain's Discord for community help. If you cannot resolve your issue there, you can write to walletsupport@parallelchain.io.</p>","tags":["Xperience browser extension"]},{"location":"for_users/xperience_browser_extension/lockup_contract/","title":"Lock-Up Contract","text":"<p>Note</p> <p>This process is the same on Xperience Browser Extension as it is on ParallelChain Explorer. </p> <p>Your XPLL allocation might be subject to a vesting schedule that determines how many of your tokens are vested (unlocked) as time goes on. You need to first register the lock-up contract of your allocation to your account so you can claim your unlocked tokens in the future, </p> <p>Note</p> <p>Each lock-up contract is unique to its holder.  </p> <p>Follow the steps below to register your lock-up contract and claim your tokens with your ParallelChain wallet.  </p> <p>Note</p> <p>Before you can perform the following steps, you need to have created and logged in to your ParallelChain account. If you are not sure how to do so, refer to Xperience Browser Extension Tutorials: Creating and Managing Your Account. </p>","tags":["Xperience extension","xpll","lockup contract"]},{"location":"for_users/xperience_browser_extension/lockup_contract/#registering-your-lock-up-contract","title":"Registering Your Lock-Up Contract","text":"","tags":["Xperience extension","xpll","lockup contract"]},{"location":"for_users/xperience_browser_extension/lockup_contract/#step-1-get-your-lock-up-contract-address","title":"Step 1: Get Your Lock-Up Contract Address","text":"<ol> <li>Your lock-up contract address would have been sent to you via email. Check your email and copy your lock-up contract address.</li> </ol>","tags":["Xperience extension","xpll","lockup contract"]},{"location":"for_users/xperience_browser_extension/lockup_contract/#step-2-register-your-lock-up-contract","title":"Step 2: Register Your Lock-Up Contract","text":"<ol> <li> <p>Click the pink file icon to the right of STAKE XPLL. </p> </li> <li> <p>Enter your lock-up contract address in the input contract address field. </p> </li> <li> <p>Click REGISTER. </p> </li> <li> <p>You will see the following information: </p> <ul> <li> <p>Locked - the tokens that currently cannot be claimed. </p> </li> <li> <p>Unlocked - the tokens that currently can be claimed. </p> </li> <li> <p>Current Phase - the vesting phase that we are in at the moment. </p> </li> <li> <p>Next Phase - the amount of time left before your tokens are vested. </p> </li> <li> <p>Contract Address - your lock-up contract address.  </p> </li> </ul> <p>Note</p> <p>You will have to manually claim the vested tokens to have them transferred to your normal account. </p> </li> <li> <p>Click CONFIRM. Your lock-up contract has now been registered. </p> <p> </p> </li> <li> <p>You will be taken back to the main page. If you scroll right, you will see your Lock-Up Contract (XPLL) balance next to your main balance. </p> </li> </ol> <p>Note</p> <p>Your account comes with a small number of XPLL to pay for the gas fee for the first transaction. For Node Round participants who will operate validator nodes on ParallelChain, the locked balance shown will be 0, as your allocation has been automatically staked on one of the existing validator nodes. </p>","tags":["Xperience extension","xpll","lockup contract"]},{"location":"for_users/xperience_browser_extension/lockup_contract/#claiming-your-vested-tokens","title":"Claiming Your Vested Tokens","text":"","tags":["Xperience extension","xpll","lockup contract"]},{"location":"for_users/xperience_browser_extension/lockup_contract/#step-1-check-your-vested-balance","title":"Step 1: Check Your Vested Balance","text":"<ol> <li> <p>Click the pink file icon to the right of STAKE XPLL. </p> </li> <li> <p>You will see the following information: </p> <ul> <li> <p>Locked - the tokens that currently cannot be claimed. </p> </li> <li> <p>Unlocked - the tokens that currently can be claimed. </p> </li> <li> <p>Current Phase - the vesting phase that we are in at the moment. </p> </li> <li> <p>Next Phase - the amount of time left before your tokens are vested. </p> </li> <li> <p>Contract Address - your lock-up contract address.  </p> </li> </ul> </li> </ol>","tags":["Xperience extension","xpll","lockup contract"]},{"location":"for_users/xperience_browser_extension/lockup_contract/#step-2-claim-your-vested-tokens","title":"Step 2: Claim Your Vested Tokens","text":"<ol> <li> <p>Click CLAIM in the Unlocked field. </p> </li> <li> <p>You will see two additional fields: </p> <ul> <li> <p>Balance - the number of tokens currently in your account. </p> </li> <li> <p>Claim - the number of tokens you wish to claim. </p> </li> </ul> </li> <li> <p>In the Claim field, enter the number of XPLL you wish to claim. This number cannot be more than the number in the Unlocked field. </p> </li> <li> <p>Click NEXT. </p> </li> <li> <p>You will see the following additional fields: </p> <ul> <li> <p>Nonce - will be automatically filled in for you. </p> </li> <li> <p>Max Base Fee per Gas - will be automatically filled in for you. The minimum fee is 8 XPLL. </p> </li> <li> <p>Priority Fee per Gas - determines the priority of your transaction. The minimum fee is 0. </p> </li> <li> <p>Gas Limit - will be automatically filled in for you. </p> </li> <li> <p>Estimated Gas Fee - the approximate gas fee that will be charged for your transaction. </p> </li> </ul> </li> <li> <p>If you are satisfied with the fields, click NEXT. </p> </li> <li> <p>Preview the summary of the transaction. Click CONFIRM to continue or CANCEL to make edits. </p> </li> <li> <p>The transaction status will show PENDING. Click CLOSE. </p> </li> <li> <p>You can check the status of your transaction in the Transactions tab. When the transaction is validated by the network, the transaction status will show SUCCESS. The claimed tokens have now been transferred to your account. </p> </li> </ol>","tags":["Xperience extension","xpll","lockup contract"]},{"location":"for_users/xperience_browser_extension/lockup_contract/#faq","title":"FAQ","text":"","tags":["Xperience extension","xpll","lockup contract"]},{"location":"for_users/xperience_browser_extension/lockup_contract/#do-i-need-to-wait-for-the-full-vesting-period-before-i-can-claim-the-locked-xpll","title":"Do I need to wait for the full vesting period before I can claim the locked XPLL?","text":"<p>A set number of XPLLs will be unlocked after a set period of time. The unlocked number of XPLL will be displayed in the Unlocked field. You may choose to claim the XPLL each time it is unlocked, but note that gas fees will have to be paid for each claim. You may also choose to accumulate the unlocked XPLL and claim it in one transaction. </p>","tags":["Xperience extension","xpll","lockup contract"]},{"location":"for_users/xperience_browser_extension/lockup_contract/#where-can-i-seek-support-or-report-bugs","title":"Where can I seek support or report bugs?","text":"<p>You can visit ParallelChain\u2019s Discord for community help. If you cannot resolve your issue there, you can write to walletsupport@parallelchain.io. </p>","tags":["Xperience extension","xpll","lockup contract"]},{"location":"for_users/xperience_browser_extension/managing_tokens/","title":"Managing Tokens","text":"<p>Note</p> <p>This process is new to Xperience Browser Extension. It is not available on ParallelChain Explorer. </p> <p>You can manage other tokens apart from XPLL using the Xperience Browser Extension. Follow the steps below to manage tokens in your ParallelChain account. </p> <p>Note</p> <p>Before you can perform the following steps, you need to have created and logged in to your ParallelChain account. If you are not sure how to do so, refer to Xperience Browser Extension Tutorials: Creating and Managing Your Account. </p>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/managing_tokens/#importing-tokens","title":"Importing Tokens","text":"<ol> <li> <p>On the main page, click the Tokens tab.  </p> </li> <li> <p>Click IMPORT.  </p> <p> </p> </li> <li> <p>Enter the token contract address in the Token contract address field.  </p> </li> <li> <p>Enter a custom name for the token in the Token Custom Name field. </p> </li> <li> <p>The Token Symbol, Token Name, and Token Decimal fields will be automatically filled in for you. </p> </li> <li> <p>Click NEXT. </p> </li> <li> <p>Preview the summary of the transaction. Click CONFIRM to continue or CANCEL to make edits. </p> <p> </p> </li> <li> <p>If you click CONFIRM, you will be taken back to the main page. Your token has now been imported and you will see it under the Tokens tab.</p> </li> </ol>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/managing_tokens/#viewing-token-details","title":"Viewing Token Details","text":"<ol> <li> <p>On the main page, click the Tokens tab.  </p> </li> <li> <p>You will see the list of tokens that you have in your wallet. </p> </li> <li> <p>Click on a token to see more details. </p> <p> </p> </li> <li> <p>You will see the following details of the token: </p> <ul> <li>Token Symbol - the token's identifying abbreviation. </li> <li>Token Name - the official name of the token. </li> <li>Decimal - the number of decimal places used to represent the token. </li> <li>Balance - the number of tokens currently in your account. </li> </ul> <p>For non-XPLL tokens, you will also see the following details: </p> <ul> <li>The Contract Address - the token contract address.  </li> <li>The Token Custom Name - the custom name you entered for the token. </li> </ul> </li> <li> <p>You can click the arrow next to the Balance field to send tokens. For more details on how to send tokens, refer to Sending Tokens. </p> </li> </ol>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/managing_tokens/#removing-imported-tokens","title":"Removing Imported Tokens","text":"<ol> <li> <p>On the main page, click the Tokens tab.  </p> </li> <li> <p>You will see the list of tokens that you have in your wallet. </p> </li> <li> <p>Click the token you wish to remove from your wallet.  </p> </li> <li> <p>Click the delete icon at the top-right corner.  </p> </li> <li> <p>Click CONFIRM to remove the token or CANCEL to go back to the previous screen. </p> </li> <li> <p>If you click CONFIRM, you will be taken back to the main page. Your token has now been removed and you will no longer see the removed token under the Tokens tab. </p> </li> </ol>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/managing_tokens/#faq","title":"FAQ","text":"","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/managing_tokens/#what-types-of-tokens-can-i-import-into-my-wallet","title":"What types of tokens can I import into my wallet?","text":"<p>In this version of Xperience Browser Extension, you can only import PRFC1 tokens to your wallet. </p>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/managing_tokens/#can-i-add-nfts-to-my-wallet","title":"Can I add NFTs to my wallet?","text":"<p>This version of Xperience Browser Extension (v1.0.2) does not support NFT.  </p>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/managing_tokens/#can-i-remove-xpll-from-my-wallet","title":"Can I remove XPLL from my wallet?","text":"<p>No, you cannot remove XPLL from your wallet. You can only remove tokens that you have imported.</p>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/managing_tokens/#where-can-i-seek-support-or-report-bugs","title":"Where can I seek support or report bugs?","text":"<p>You can visit ParallelChain\u2019s Discord for community help. If you cannot resolve your issue there, you can write to walletsupport@parallelchain.io. </p>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/staking/","title":"Staking XPLL","text":"<p>Note</p> <p>This process is the same on Xperience Browser Extension as it is on ParallelChain Explorer. </p> <p>You can stake XPLL with network validators to help secure the blockchain and earn rewards. Follow the steps below to stake XPLL tokens with your ParallelChain account. </p> <p>Note</p> <p>Before you can perform the following steps, you need to have created and be logged in to your ParallelChain account. If you are not sure how to do so, refer to Xperience Browser Extension Tutorials: Creating and Managing Your Account. </p>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#depositing-your-xpll","title":"Depositing Your XPLL","text":"","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#step-1-select-a-validator","title":"Step 1: Select a Validator","text":"<ol> <li>Click STAKE XPLL.</li> <li>You will see the list of validators. Select a validator from the list, or search for a specific validator via the search bar at the top.</li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#step-2-deposit-xpll","title":"Step 2: Deposit XPLL","text":"","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#through-your-account","title":"Through Your Account","text":"<ol> <li>You will see the following details of the validator:<ul> <li>Pool Name - the name of the validator</li> <li>Operator - the validator's address</li> <li>Pool Stake - the number of XPLL staked with the validator</li> <li>Commission Fee - the percentage of your rewards the validator will take as a commission fee</li> </ul> </li> <li>Enter the number of XPLL you wish to deposit in the Deposit field.</li> <li>If you woould like to stake your rewards automatically, toggle the Auto Stake Rewards button on.</li> <li>Click Next.</li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#through-your-lock-up-contract","title":"Through Your Lock-Up Contract","text":"<ol> <li> <p>You will see the following details of the validator pool:</p> <ul> <li>Lock-Up Contract(XPLL)/ Locked - the number of tokens that are still vested</li> <li>Pool Name - the name of the validator</li> <li>Operator - the validator's address</li> <li>Pool Stake - the number of XPLL staked with the validator</li> <li>Commission Fee - the percentage of your rewards the validator will take as a commission fee</li> </ul> </li> <li> <p>The Deposit field will be automatically filled in for you when you deposit XPLL through your lock-up contract.</p> </li> <li>If you would like to stake your rewards automatically, toggle the Auto Stake Rewards button on.</li> <li>Click Next.</li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#step-3-confirm-your-transaction","title":"Step 3: Confirm Your Transaction","text":"<ol> <li> <p>You will see the following additional fields:</p> <ul> <li>Nonce - will be automatically filled in for you.</li> <li>Max Base Fee per Gas - will be automatically filled in for you based on the current Base Fee per Gas of the network.</li> <li>Priority Fee per Gas - determines the priority of your transaction. The minimum fee is 0 XPLL.</li> <li>Gas Limit - will be automatically filled in for you.</li> <li>Estimated Gas Fee - the approximate gas fee that will be charged for your transaction.</li> </ul> </li> <li> <p>If you are satisfied with the fields, click Next.</p> </li> <li> <p>Preview the summary of the transaction. Click CONFIRM to confirm or CANCEL to make edits.</p> </li> <li> <p>You will see the details of the transaction. The transaction status will show PENDING. Click CLOSE.</p> <p> </p> </li> <li> <p>You can check the status of your transaction in the Transaction tab. It is labelled CREATE DEPOSIT. When the transaction is validated by the network, the transaction status will show SUCCESS. Your XPLL have now been deposited with the validator.</p> </li> <li> <p>You can create more than one deposit by repeating the above process with different validators.</p> </li> <li> <p>To start earning XPLL from staking, follow the instruction in the Staking Your XPLL section below.</p> </li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#staking-your-xpll","title":"Staking Your XPLL","text":"<p>You can stake the XPLL that you have deposited with the validators to earn rewards.</p>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#step-1-navigate-to-your-chosen-validator","title":"Step 1: Navigate to Your Chosen Validator","text":"<ol> <li> <p>On the main page, click the Stakes tab.</p> </li> <li> <p>Click the validator that you wish to stake XPLL with.</p> </li> <li> <p>You will see the following details of the validator:</p> <ul> <li>Pool Name - the name of the validator.</li> <li>Operator - the validator's address.</li> <li>Pool Stake - the number of XPLL staked with the validator.</li> <li>Commission Fee - the percentage of your rewards that validator will take as a commission fee.</li> </ul> <p>You will also see the following information:</p> <ul> <li>Deposit - the number of XPLL you have deposited with the validator.</li> <li>Tentative Stake - the number of XPLL you have in the validator pool that will become part of the current stake in the future.</li> <li>Current Stake - the number of XPLL you have in the validator pool that is part of the current validator set and is now earning rewards.</li> <li>Auto Stake Rewards - whether you have chosen to stake your rewards automatically.</li> <li>Next Epoch - when the next epoch will occur.</li> </ul> <p> </p> </li> <li> <p>Click the arrow beside the Tentative Stake field. </p> </li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#step-2-stake-xpll","title":"Step 2: Stake XPLL","text":"","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#from-your-account","title":"From Your Account","text":"<ol> <li> <p>You will see the following details of the validator:</p> <ul> <li>Pool Name - the name of the validator.</li> <li>Operator - the validator's address.</li> <li>Pool Stake - the number of XPLL staked with the validator.</li> <li>Commission Fee - the percentage of your rewards that validator will take as a commission fee.</li> <li>Deposit - the number of XPLL you have deposited with the validator.</li> <li>Tentative Stake - the number of XPLL you have in the validator pool that will become part of the current stake in the future.</li> </ul> </li> <li> <p>If this is your first stake with the validator, you will see the Stake field. If you have an existing stake with the validator, click STAKE, and the Stake field will appear.</p> </li> <li> <p>Enter the number of XPLL you wish to stake in the Stake field. The number cannot exceed the number of XPLL you have deposited.</p> </li> <li> <p>Click Next.</p> </li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#from-your-lock-up-contract","title":"From Your Lock-Up Contract","text":"<ol> <li> <p>You will see the following details of the validator: </p> <ul> <li>Lock-Up Contract (XPLL)/Locked - the number tokens that are still vested. </li> <li>Pool Name - the name of the validator. </li> <li>Operator - the validator's address.</li> <li>Pool Stake - the number of XPLL staked with the validator.</li> <li>Commission Fee - the percentage of your rewards that validator will take as a commission fee.</li> <li>Deposit - the number of XPLL you have deposited with the validator.</li> <li>Tentative Stake - the number of XPLL you have in the validator pool that will become part of the current stake in the future.</li> </ul> </li> <li> <p>The Stake fild will be automatically filled in for you hen you stake XPLL from your lock-up contract.</p> </li> <li> <p>Click Next.</p> </li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#step-3-confirm-your-transaction_1","title":"Step 3: Confirm Your Transaction","text":"<ol> <li> <p>You will see the following additional fields:</p> <ul> <li>Nonce - will be automatically filled in for you.</li> <li>Max Base Fee per Gas - will be automatically filled in for you based on the current Base Fee per Gas of the network.</li> <li>Priority Fee per Gas - determines the priority of your transaction. The minimum fee is 0 XPLL.</li> <li>Gas Limit - will be automatically filled in for you.</li> <li>Estimated Gas Fee - the approximate gas fee that will be charged for your transaction.</li> </ul> </li> <li> <p>If you are satisfied with the fields, click NEXT.</p> </li> <li>Preview the summary of the tranasction. Click CONFIRM to continue or CANCEL to make edits.</li> <li> <p>You will see the detais of the transaction. The transaction status will show PENDING. Click CLOSE.</p> <p> </p> </li> <li> <p>You can check the status of your transaction in the Transactions tab. It is labelled STAKE DEPOSIT. When the transaction is validated by the network, the transaction status will show SUCCESS. Your XPLL have now been staked with the validator. </p> </li> </ol> <p>Note</p> <p>Depending on the network state when your transaction gets included, the actual amount may differ slightly from your desired amount.</p>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#topping-up-your-stake","title":"Topping Up Your Stake","text":"","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#step-1-navigate-to-your-chosen-validator_1","title":"Step 1: Navigate to Your Chosen Validator","text":"<ol> <li>On the main page, click the Stakes tab.</li> <li>Click the validator pool that you wish to top up your deposit with.</li> <li> <p>You will see the following details of the validator:</p> <ul> <li>Pool Name - the name of the validator.</li> <li>Operator - the validator's address.</li> <li>Pool Stake - the number of XPLL staked with the validator.</li> <li>Commission Fee - the percentage of your rewards that validator will take as a commission fee.</li> </ul> <p>You will also see the following information:</p> <ul> <li>Deposit - the number of XPLL you have deposited with the validator.</li> <li>Tentative Stake - the number of XPLL you have in the validator pool that will become part of the current stake in the future.</li> <li>Current Stake - the number of XPLL you have in the validator pool that is part of the current validator set and is now earning rewards.</li> <li>Auto Stake Rewards - whether you have chosen to stake your rewards automatically.</li> <li>Next Epoch - when the next epoch will occur.</li> </ul> <p> </p> </li> <li> <p>Click the arrow beside the Deposit field.</p> </li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#step-2-top-up-your-stake-through-your-account","title":"Step 2: Top-Up Your Stake Through Your Account","text":"<ol> <li> <p>You will see the following details of the validator:</p> <ul> <li>Pool Name - the name of the validator.</li> <li>Operator - the validator's address.</li> <li>Pool Stake - the number of XPLL staked with the validator.</li> <li>Commission Fee - the percentage of your rewards that validator will take as a commission fee.</li> <li>Deposit - the number of XPLL you have deposited with the validator.</li> <li>Tentative Stake - the number of XPLL you have in the validator pool that will become part of the current stake in the future.</li> </ul> </li> <li> <p>Click TOP-UP to deposit more XPLL with the validator.</p> </li> <li>The Top-Up field will appear. Enter the number of XPLL you wish to top up. The number cannot be more than your account balance.</li> <li>Click NEXT.</li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#step-3-confirm-your-transaction_2","title":"Step 3: Confirm Your Transaction","text":"<ol> <li> <p>You will see the following additional fields:</p> <ul> <li>Nonce - will be automatically filled in for you.</li> <li>Max Base Fee per Gas - will be automatically filled in for you based on the current Base Fee per Gas of the network.</li> <li>Priority Fee per Gas - determines the priority of your transaction. The minimum fee is 0 XPLL.</li> <li>Gas Limit - will be automatically filled in for you.</li> <li>Estimated Gas Fee - the approximate gas fee that will be charged for your transaction.</li> </ul> </li> <li> <p>If you are satisfied with the fields, click NEXT.</p> </li> <li>Preview the summary of the transaction. Click CONFIRM to continue or CANCEL to make edits.</li> <li>The transaction will show PENDING. Click CLOSE.</li> </ol> <p> </p> <ol> <li>You can check the status of your transaction in the Transaction tab. It is labelled TOP UP DEPOSIT. When the transaction is validated by the network, the transaction status will show SUCCESS. Your deposit has now been topped up.</li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#unstaking-your-xpll","title":"Unstaking Your XPLL","text":"","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#step-1-navigate-to-your-chosen-validator_2","title":"Step 1: Navigate to Your Chosen Validator","text":"<ol> <li>On the main page, click the Stakes tab.</li> <li>Click the validator pool that you wish to unstake XPLL from.</li> <li> <p>You will see the following details of the validator:</p> <ul> <li>Pool Name - the name of the validator.</li> <li>Operator - the validator's address.</li> <li>Pool Stake - the number of XPLL staked with the validator.</li> <li>Commission Fee - the percentage of your rewards that validator will take as a commission fee.</li> </ul> <p>You will also see the following information:</p> <ul> <li>Deposit - the number of XPLL you have deposited with the validator.</li> <li>Tentative Stake - the number of XPLL you have in the validator pool that will become part of the current stake in the future.</li> <li>Current Stake - the number of XPLL you have in the validator pool that is part of the current validator set and is now earning rewards.</li> <li>Auto Stake Rewards - whether you have chosen to stake your rewards automatically.</li> <li>Next Epoch - when the next epoch will occur.</li> </ul> <p> </p> </li> <li> <p>Click the arrow beside the Tentative Stake field.</p> </li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#step-2-unstake-xpll","title":"Step 2: Unstake XPLL","text":"","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#to-your-account","title":"To Your Account","text":"<ol> <li> <p>You will see the following details of the validator:</p> <ul> <li>Pool Name - the name of the validator.</li> <li>Operator - the validator's address.</li> <li>Pool Stake - the number of XPLL staked with the validator.</li> <li>Commission Fee - the percentage of your rewards that validator will take as a commission fee.</li> <li>Deposit - the number of XPLL you have deposited with the validator.</li> <li>Tentative Stake - the number of XPLL you have in the validator pool that will become part of the current stake in the future.</li> </ul> </li> <li> <p>Click UNSTAKE.</p> </li> <li>The Unstake field will appear. Enter the number of XPLL you wish to unstake. The number cannot exceed the number of XPLL you have staked.</li> <li>Click NEXT.</li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#to-your-lock-up-contract","title":"To Your Lock-Up Contract","text":"<ol> <li> <p>You will see the following details of the validator: </p> <ul> <li>Lock-Up Contract (XPLL)/Locked - the number tokens that are still vested. </li> <li>Pool Name - the name of the validator. </li> <li>Operator - the validator's address.</li> <li>Pool Stake - the number of XPLL staked with the validator.</li> <li>Commission Fee - the percentage of your rewards that validator will take as a commission fee.</li> <li>Deposit - the number of XPLL you have deposited with the validator.</li> <li>Tentative Stake - the number of XPLL you have in the validator pool that will become part of the current stake in the future.</li> </ul> </li> <li> <p>The Unstake field will be automatically filled in for you when you unstake XPLL to your lock-up contract.</p> </li> <li>Click NEXT.</li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#step-3-confirm-your-transaction_3","title":"Step 3: Confirm Your Transaction","text":"<ol> <li> <p>You will see the following additional fields:</p> <ul> <li>Nonce - will be automatically filled in for you.</li> <li>Max Base Fee per Gas - will be automatically filled in for you based on the current Base Fee per Gas of the network.</li> <li>Priority Fee per Gas - determines the priority of your transaction. The minimum fee is 0 XPLL.</li> <li>Gas Limit - will be automatically filled in for you.</li> <li>Estimated Gas Fee - the approximate gas fee that will be charged for your transaction.</li> </ul> </li> <li> <p>If you are satisfied with the fields, click NEXT.</p> </li> <li>Preview the summary of the tranasction. Click CONFIRM to continue or CANCEL to make edits.</li> <li> <p>You will see the detais of the transaction. The transaction status will show PENDING. Click CLOSE.</p> <p> </p> </li> <li> <p>You can check the status of your transaction in the Transactions tab. It is labelled UNSTAKE DEPOSIT. When the transaction is validated by the network, the transaction status will show SUCCESS. Your XPLL have now been unstaked from the validator.</p> </li> </ol> <p>Note</p> <p>Depends on the network state when your transaction gets included, the actual amount may differ slightly from your desired amount.</p>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#withdrawing-your-stakes","title":"Withdrawing Your Stakes","text":"","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#step-1-navigate-to-your-chosen-validator_3","title":"Step 1: Navigate to Your Chosen Validator","text":"<ol> <li>On the main page, click the Stakes tab.</li> <li>Click the validator that you wish to withdraw XPLL from.</li> <li> <p>You will see the following details of the validator:</p> <ul> <li>Pool Name - the name of the validator.</li> <li>Operator - the validator's address.</li> <li>Pool Stake - the number of XPLL staked with the validator.</li> <li>Commission Fee - the percentage of your rewards that validator will take as a commission fee.</li> </ul> <p>You will also see the following information:</p> <ul> <li>Deposit - the number of XPLL you have deposited with the validator.</li> <li>Tentative Stake - the number of XPLL you have in the validator pool that will become part of the current stake in the future.</li> <li>Current Stake - the number of XPLL you have in the validator pool that is part of the current validator set and is now earning rewards.</li> <li>Auto Stake Rewards - whether you have chosen to stake your rewards automatically.</li> <li>Next Epoch - when the next epoch will occur.</li> </ul> <p> </p> </li> <li> <p>Click the arrow beside the Deposit field.</p> </li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#step-2-withdraw-stakes","title":"Step 2: Withdraw Stakes","text":"","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#to-your-account_1","title":"To Your Account","text":"<ol> <li> <p>You will see the following details of the validator:</p> <ul> <li>Pool Name - the name of the validator.</li> <li>Operator - the validator's address.</li> <li>Pool Stake - the number of XPLL staked with the validator.</li> <li>Commission Fee - the percentage of your rewards that validator will take as a commission fee.</li> <li>Deposit - the number of XPLL you have deposited with the validator.</li> <li>Tentative Stake - the number of XPLL you have in the validator pool that will become part of the current stake in the future.</li> </ul> </li> <li> <p>Click WITHDRAW to withdraw XPLL from your validator deposit.</p> </li> <li>The Withdraw field will appear. Enter the number of XPLL you wish to withdraw. The number cannot be more than your account balance.</li> <li>Click NEXT.</li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#to-your-lock-up-contract_1","title":"To Your Lock-Up Contract","text":"<ol> <li> <p>You will see the following details of the validator: </p> <ul> <li>Lock-Up Contract (XPLL)/Locked - the number tokens that are still vested. </li> <li>Pool Name - the name of the validator. </li> <li>Operator - the validator's address.</li> <li>Pool Stake - the number of XPLL staked with the validator.</li> <li>Commission Fee - the percentage of your rewards that validator will take as a commission fee.</li> <li>Deposit - the number of XPLL you have deposited with the validator.</li> <li>Tentative Stake - the number of XPLL you have in the validator pool that will become part of the current stake in the future.</li> </ul> </li> <li> <p>The Withdraw field will be automatically filled in for you when you withdraw XPLL to your lock-up contract. Depends on the time when you withdraw your XPLL, the withdrawal may be split between your lock-up contract's locked and unlocked tokens.</p> </li> <li>Click NEXT.</li> </ol>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#step-3-confirm-your-transaction_4","title":"Step 3: Confirm Your Transaction","text":"<ol> <li> <p>You will see the following additional fields:</p> <ul> <li>Nonce - will be automatically filled in for you.</li> <li>Max Base Fee per Gas - will be automatically filled in for you based on the current Base Fee per Gas of the network.</li> <li>Priority Fee per Gas - determines the priority of your transaction. The minimum fee is 0 XPLL.</li> <li>Gas Limit - will be automatically filled in for you.</li> <li>Estimated Gas Fee - the approximate gas fee that will be charged for your transaction.</li> </ul> </li> <li> <p>If you are satisfied with the fields, click NEXT.</p> </li> <li>Preview the summary of the tranasction. Click CONFIRM to continue or CANCEL to make edits.</li> <li> <p>You will see the detais of the transaction. The transaction status will show PENDING. Click CLOSE.</p> <p> </p> </li> <li> <p>You can check the status of your transaction in the Transactions tab. It is labelled WITHDRAW DEPOSIT. When the transaction is validated by the network, the transaction status will show SUCCESS. Your XPLL have now been withdrawn.</p> </li> </ol> <p>Note</p> <p>Depending on the network state when your transaction gets included, the actual amount may differ slightly from your desired amount.</p>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#faq","title":"FAQ","text":"","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#why-am-i-not-able-to-stake-xpll-tokens","title":"Why am I not able to stake XPLL tokens?","text":"<p>You will need to retain a certain number of XPLL in your account balance to pay for transaction fees. Ensure that you have reserved enough XPLL to pay for the gas fees for depositing, staking, unstaking, topping up, or withdrawing XPLL.</p>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#how-do-i-know-which-validator-to-stake-with","title":"How do I know which validator to stake with?","text":"<p>All the validators securing ParallelChain Mainnet are trusted participants who are required to stake a significant number of XPLL. You can check the yield and commission fee of each validator by tapping on the drop-down arrow of the Operator field.</p>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#how-long-is-the-unstaking-period","title":"How long is the unstaking period?","text":"<p>The staking duration is measured by epochs. If you stake and unstake within the same epoch, the waiting time is considerably shorter. If you do not stake and unstake within the same epoch, you will need to wait at least for another two epochs before unstaking. </p>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#how-long-is-an-epoch","title":"How long is an epoch?","text":"<p>One full epoch lasts approximately one day before it enters the next epoch. The epoch is a protocol-defined period for measuring performance of operators on the network. </p>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#how-do-i-withdraw-my-staking-rewards","title":"How do I withdraw my staking rewards?","text":"<p>You can withdraw the rewards you have earned from staking by unstaking them to your token deposit. Additionally, you may toggle Auto Stake Rewards on to avoid the process of unstaking your rewards. After that, you can withdraw the rewards to your account balance. Please refer to the section on Unstaking Your XPLL and Withdrawing Your Stakes for the required steps. </p>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#can-i-move-my-staked-xpll-to-another-validator","title":"Can I move my staked XPLL to another validator?","text":"<p>Yes, you can. You will need to unstake your XPLL tokens to move them to your token deposit, then withdraw them to your account balance. You can then deposit those tokens to another validator pool, then stake your tokens with them.  </p>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#the-transaction-status-is-still-showing-pending-why-is-my-transaction-not-confirmed-yet","title":"The transaction status is still showing \u2018PENDING\u2019. Why is my transaction not confirmed yet?","text":"<p>Transactions are prioritised by the amount of Priority Fee per Gas paid. Lower priority transactions may need more time to be confirmed. You may choose to pay a higher Priority Fee during peak periods for a faster transaction, or continue checking your wallet address to monitor the transaction status. </p>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/staking/#where-can-i-seek-support-or-report-bugs","title":"Where can I seek support or report bugs?","text":"<p>You can visit ParallelChain\u2019s Discord for community help. If you cannot resolve your issue there, you can write to walletsupport@parallelchain.io. </p>","tags":["Xperience extension","staking","xpll"]},{"location":"for_users/xperience_browser_extension/transfer_tokens/","title":"Transferring Tokens","text":"<p>Note</p> <p>This process is the same on Xperience Browser Extension as it is on ParallelChain Explorer. </p> <p>Sending and receiving assets with digital wallets is a keystone of any blockchain\u2019s decentralised infrastructure. Follow the steps below to send and receive tokens with your ParallelChain account.</p> <p>Note</p> <p>Before you can perform the following steps, you need to have created and logged in to your ParallelChain account. If you are not sure how to do so, refer to Xperience Browser Extension Tutorials: Creating and Managing Your Account. </p>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/transfer_tokens/#sending-tokens","title":"Sending Tokens","text":"","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/transfer_tokens/#step-1-fill-in-transaction-details","title":"Step 1: Fill in Transaction Details","text":"<ol> <li>Click SEND.</li> <li>Select the token to send by clicking the down arrow in the Token field.</li> <li> <p>Enter the address that you want to send tokens to in the To Address field.</p> <p>Note</p> <p>If you are transferring tokens between your own accounts, you can access your different accounts by clicking the down arrow next to your account name and address. You can copy the address of the receiving account by clicking the copy icon beside its address. </p> <ol> <li>Enter the number of tokens you would like to send in the Send field. The amount must not be a negative number, and it cannot be more than the number of tokens you currently have.</li> <li>Click NEXT.</li> </ol> </li> </ol>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/transfer_tokens/#step-2-confirm-your-transaction","title":"Step 2: Confirm Your Transaction","text":"<ol> <li>You will see the following additional fields:<ul> <li>Nonce - will be automatically filled in for you.</li> <li>Max Base Fee per Gas - will be automatically filled in for you. The minimum fee is 8 XPLL.</li> <li>Priority Fee per Gas - determines the priority of your transaction. The minimum fee is 0 XPLL.</li> <li>Gas Limit - will be automatically filled in for you.</li> <li>Estimated Gas Fee - the approximate gas fee that will be charged for your transaction.</li> </ul> </li> <li> <p>If you are satisfied with the fields, click NEXT.</p> </li> <li> <p>Preview the summary of the transaction. Click CONFIRM to confirm or CANCEL to make edits.</p> </li> <li> <p>The transaction status will show PENDING. Click CLOSE.</p> <p> </p> </li> <li> <p>You can check the status of your transaction in the Transactions tab. It is labeled TRANSFER. When the transaction is validated by the network, the transaction status will show SUCCESS. Your tokens have now been sent.  </p> </li> </ol>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/transfer_tokens/#receiving-xpll-tokens","title":"Receiving XPLL Tokens","text":"","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/transfer_tokens/#step-1-share-your-wallet-address","title":"Step 1: Share Your Wallet Address","text":"<ol> <li>Click the copy icon next to your wallet address to copy it.</li> <li>Share your wallet address with the sender through a secure text messaging application.</li> <li>The sender should use your wallet address and follow the steps in Sending Tokens to send you the tokens.</li> </ol>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/transfer_tokens/#step-2-receive-your-tokens","title":"Step 2: Receive Your Tokens","text":"<ol> <li>Wait for the sender to confirm the transaction. Be patient as the transaction takes time to be validated by the network.</li> <li>Once the transaction is confirmed, your wallet balance will be automatically updated.</li> </ol>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/transfer_tokens/#faq","title":"FAQ","text":"","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/transfer_tokens/#what-tokens-can-i-send-or-receive","title":"What tokens can I send or receive?","text":"<p>You can send or receive XPLL using either Xperience Browser Extension or ParallelChain Explorer. However, you can only send or receive PRFC1 tokens using Xperience Browser Extension for now.</p>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/transfer_tokens/#i-have-not-received-my-tokens-where-can-i-check-the-transaction-status","title":"I have not received my tokens. Where can I check the transaction status?","text":"<p>To check the transaction status of the token transfer, you can use ParallelChain Explorer.</p> <p>Click on your wallet address in Xperience Browser Extension. This will open ParallelChain Explorer. Enter your wallet address in the search field. Under the Transactions section, RECEIVED tab, you can see your transactions for receiving tokens. </p>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/transfer_tokens/#can-i-cancel-or-refund-transactions","title":"Can I cancel or refund transactions?","text":"<p>No, once a transaction request has been made, it cannot be cancelled. </p>","tags":["Xperience extension","xpll"]},{"location":"for_users/xperience_browser_extension/transfer_tokens/#where-can-i-seek-support-or-report-bugs","title":"Where can I seek support or report bugs?","text":"<p>You can visit ParallelChain\u2019s Discord for community help. If you cannot resolve your issue there, you can write to walletsupport@parallelchain.io. </p>","tags":["Xperience extension","xpll"]},{"location":"fundamentals/accounts/","title":"Accounts","text":"<p>Account is the basic identity of an agent on the blockchain. An account is identified by its address. </p> <p>In Parallelchain Mainnet, accounts are divided into two types:</p> <ul> <li>Externally Owned Accounts (EOA): The address of an EOA is the public key of the keypair that is compatible with ed25519-dalek.</li> <li>Contract Accounts: A contract account is created from contract deployment. The address is the SHA256 hash of the concatenation of a contract's bytecode and the nonce of the EOA that deploys the contract. </li> </ul> <p>Elements inside an account include:</p> <ul> <li>Nonce: The number of transactions made to the blockchain under this account.</li> <li>Balance: The balance of the account.</li> </ul> <p>The followings are elements that only apply to Contract Accounts:</p> <ul> <li>Contract Code: The binary of the smart contract that was deployed to the blockchain (applies to Contract Accounts).</li> <li>CBI Version: The version of the Contract Binary Interface.</li> <li>Storage Hash: The 32-byte SHA256 root hash of its Storage Trie. This is empty for an External.</li> </ul>","tags":["Account","EOA","Network Account"]},{"location":"fundamentals/accounts/#how-account-works","title":"How Account Works","text":"<p>You can create EOA account by ed25519-dalek key generation algorithm. The account is composed of a 32-byte public key and a 32-byte private key. This public key is the Address which can be known to others. While your private key, which is used for signing transactions, MUST be kept in secret.</p> <p>Address is usually displayed in Base64url format in ParallelChain Mainnet ecosystem. Here is an example:</p> <pre><code>Tc0bU2oS0A0_GrjPKsDLSyVa3gc7PvzwWIAGRk-_SmA\n</code></pre> <p>If you want to transfer XPLL to Alice's account, first you need to know her address. Then, you create a transaction with Alice's address as recipient, and sign it by using your private key. The Balance of your and Alice's account will be updated when this signed transaction is made to blockchain successfully. The Nonce of your account will be increased by 1.</p> <p>On the other hand, a Contract Account is not made up of cryptographic keys. Its address is a 32-byte hash. It is not able to sign a transaction. But similar to EOA, it has its own balance, and can receive XPLL from other accounts. See Smart Contract for details.</p> <p>Note</p> <p>The type of account cannot be distinguished from each other just by looking at the address format.</p> <p>See also:</p> <ul> <li>Create Account by CLI</li> <li>Create Account by Web Wallet</li> <li>Create Account by Xperience Browser Extension</li> </ul>","tags":["Account","EOA","Network Account"]},{"location":"fundamentals/accounts/#network-account","title":"Network Account","text":"<p>A Network Account is a single identified network-wide account that maintains the state of ParallelChain Mainnet. The purpose of this state is to implement the staking related protocol. This account is not associated with Ed25519 material. The network-significant data that the Network Account stores are composed of various fields:</p> <ul> <li>Previous Validator Set: The set of pools that form the validator set in the previous epoch. The stake in this validator set is locked until the next epoch.</li> <li>Current Validator Set: The set of pools that form the validator set in the current epoch.</li> <li>Next Validator Set: The limited-size pools with the largest powers. These will become the validator set in the next epoch.</li> <li>Pools: The set of pools that are accepting stakes and currently competing to become part of the next validator set.</li> <li>Deposits: The locked balance used to determine the amount of stake that can be contributed to a pool.</li> <li>Current Epoch: The current epoch number.</li> </ul>","tags":["Account","EOA","Network Account"]},{"location":"fundamentals/blocks/","title":"Blocks","text":"<p>Block is a fundamental data structure in a blockchain. It describes execution of a batch of transactions. Blocks are \"chained\" by attaching a cryptographic hash of an earlier block. The hash is the proof of the data integrity of the earlier blocks because if their content have been changed, the hash will not be the same. This is how blockchain provides data immutability.</p> <p>Summary of the elements inside a block:</p> <ul> <li><code>Hash</code> - the unique identifier for the block</li> <li><code>Height</code> - a number that represents the position of the block on the blockchain</li> <li><code>Justify</code> - a certificate that proves the block was authorized by the network</li> <li><code>Data Hash</code> - a hash that covers the content of the block header</li> <li><code>Chain ID</code> - a number that identifies a particular Parallelchain Mainnet-based blockchain</li> <li><code>Proposer</code> - the public address of the block producer</li> <li><code>Timestamp</code> - the time the block was created, measured in seconds since 1970-01-01</li> <li>Base Fee Per Gas - the minimum number of grays that a transaction must pay for every gas used to be included in the block</li> <li><code>Gas Used</code> - the amount of gas used in a block, which is the total sum of the gas used in executing the included transactions</li> <li><code>Transactions Hash</code> - the root hash of the Merkle Tree that contains the transactions included in the block</li> <li><code>Receipt Hash</code> - the root hash of the Merkle Tree that contains the execution results of the transactions included in the block</li> <li><code>State Hash</code> - the root hash of the Merkle Tree that represents the current world state</li> <li><code>Log Bloom</code> - a 256-byte block-level Bloom Filter that combines all the Bloom Filters of each Log topic from the block's receipts</li> <li>Transactions - the transactions that are included in the block</li> <li>Receipts - the execution results of the transactions that are included in the block</li> </ul>","tags":["Block Header"]},{"location":"fundamentals/blocks/#inside-a-block","title":"Inside a Block","text":"<p>Each block contains a unique identifier known as the <code>block hash</code>, which is calculated based on the contents of the block. The block hash acts as a fingerprint for the block, making it tamper-evident. Any change to the block's contents would alter its hash, making it easily detectable by network participants.</p> <p>The block header contains important metadata about the block, including the block's <code>height</code>, <code>timestamp</code>, and the <code>address of the block producer</code>, among others. It also includes Merkle Patricia Tree root hashes for transactions, receipts, and the current state of the blockchain.</p> <p>Transactions contained within the block are executed by the blockchain system, with the results recorded in receipts. These receipts contain information about the execution status of each transaction and are stored in a Merkle Patricia Tree, with the root hash included in the block header.</p> <p>In addition to transactions and receipts, the block also contains a Bloom filter, which is a probabilistic data structure used to efficiently query logs associated with the transactions contained in the block.</p> <p>Example of a block queried by ParallelChain Client CLI:</p> <pre><code>{\n  \"header\": {\n    \"chain_id\": 10000,\n    \"block_hash\": \"Yn0SAN6KDA3v2uDjN_j1P_tFCCqgqCbak1g7zvHwr9Q\",\n    \"height\": 2844080,\n    \"justify\": {\n      \"chain_id\": 10000,\n      \"view\": 2844930,\n      \"block\": \"zT3iUT2sCmD80ztBDScBlAvUXhbzba7RTLtSiBLsvRg\",\n      \"phase\": \"Generic\",\n      \"signatures\": {\n        \"signatures\": [\n          \"hin8bfLnbuuUBRVB7GbClI0g1Ad0rfM_oDfvYILhwKPG_eqqZEDVyNj1c1VZeeRuUW94pqEQzAqbz4zQuTz0Dg\",\n          \"5usLkVtsEsFCIHQOKi8X_LjvMxzBd4xxJJz7QSbl1pGLimFUkpV5MCBi1SGRY9jVHCArxu6v3B_jn3xCZfhrCg\",\n          null,\n          null,\n          \"XqLSsQP6YkvtbBpPo7NX4o2Q7GvjAU-5dHfKPiDrdIBZPzTric_LvqJCgZLemUmzKkELkUl9BCBtFLth61qhAg\",\n          null,\n          null,\n          null,\n          \"PWhCgGM_SQpEf3NTZIdEIHecaFEd9MHptZqUyM4l7J4oR5aMrxkPYLRQ89msWfRtCF6fSvYVLZhTR-FjcIJqBg\",\n          \"lLnEWWKxoToD-URLN7PDWFBQTyC1waS9KHBAskgdXdn_bZIyr3XYoqxIbTcHW6f0m6qozQGkZTXQukGbi08fCA\"\n        ]\n      }\n    },\n    \"data_hash\": \"Tr4Z99mUiaHGVuzW5eyZ73bKqEXUcYPV1C5RkUVCP2U\",\n    \"timestamp\": 1711515120,\n    \"base_fee\": 8,\n    \"txs_hash\": \"wDUDiSjWumCmyEu_Fz0H8zqs3jSlpCMxN2NnST7fieM\",\n    \"state_hash\": \"rU3ilPOG1Lr-4fYtGTHpSXsMvZM8v0l5JX3PgK-wauc\",\n    \"receipts_hash\": \"uXRT1micHUt7orVPifaFg5BvOQJLd9K4mNAFo0zW0x4\",\n    \"proposer\": \"TY0vjFcDm681NupNBVSU9DKNunP6JlwNNhc7lDJ2uU0\"\n  },\n  \"transactions\": [\n    {\n      \"commands\": [\n        {\n          \"Transfer\": {\n            \"recipient\": \"kxrCl32WEzr7gr4Awb3jAMQtoh5zY8grabqlu-x42jY\",\n            \"amount\": 2000000000\n          }\n        }\n      ],\n      \"signer\": \"qPReY5x_DPKAx1v30UrU1x1RI61Wd2OxeZo2eSWcjMU\",\n      \"priority_fee_per_gas\": 0,\n      \"gas_limit\": 67500000,\n      \"max_base_fee_per_gas\": 8,\n      \"nonce\": 428,\n      \"hash\": \"dOrjtT7o5Y97mlLJFaCvdNUq6UgVQItVYGXHPoDw5n4\",\n      \"signature\": \"RLM3k5VDDzBqkQ7ios4TMP9LwL50n8hNQ7OjH-wcTE0Ts6F3uWDaA5J52sCyYr3aGGGElXKiIatqH15qVwMUAA\"\n    }\n  ],\n  \"receipts\": [\n    [\n      {\n        \"status_code\": \"Success\",\n        \"gas_used\": 32820,\n        \"return_values\": \"\",\n        \"logs\": []\n      }\n    ]\n  ]\n}\n</code></pre>","tags":["Block Header"]},{"location":"fundamentals/blocks/#how-block-works","title":"How Block Works","text":"<p>Blocks are produced by validator Nodes. To produce a block, the node executes transactions and creates receipts as a result of execution. The transactions and receipts become the content of a block, and the node will then compute the metadata such as <code>block height</code>, <code>timestamp</code>, hashes, etc. in the block header.</p> <p>When a block is created by a node, the validator nodes will validate it and then agree on the block content through a consensus mechanism. An agreed block is said to be committed. If the block is invalid, it will not be part of the blockchain. Nodes will keep producing new blocks, and this process repeats within a time interval (i.e. block time). As a result, the blockchain grows with more and more blocks.</p>","tags":["Block Header"]},{"location":"fundamentals/blocks/#epoch-block","title":"Epoch Block","text":"<p>Epoch Block is a special block created by executing a transaction with Next Epoch Command. This special block signifies the last block in an Epoch.</p> <p>Epoch is a protocol-defined period for measuring the performance of operators on the blockchain network. </p> <p>The primary purpose of epochs in a blockchain is to facilitate various network functionalities and maintain consensus among network participants by defining a common reference point, which could be utilized to validate transactions. During one epoch, there would be block creation and block addition to the blockchain.</p> <p>In the ParallelChain Mainnet ecosystem, an <code>epoch</code> is defined by a predetermined block height or the number of blocks added to the blockchain, which is 8640. When a specific block height is reached or another 8640 blocks are added to the blockchain, the blockchain network would move from the current epoch to the next. The epoch transition could trigger critical events:</p> <ul> <li> <p>Reward stakes in Current Validator Set</p> <ul> <li>Increase deposits of owner and operator</li> <li>Update stakes if auto-stake-rewards is enabled</li> </ul> </li> <li> <p>Replacing Previous Validator Set with Current Validator Set</p> </li> <li>Replacing Current Validator Set with Next Validator Set</li> <li>Returning Next Validator Set for the next leader selection</li> </ul> <p>Epoch transition ensures that only one set of validators is active on the blockchain network at any given time, which makes the information on the blockchain tamper-proof.</p>","tags":["Block Header"]},{"location":"fundamentals/consensus_mechanism/","title":"Consensus Mechanism","text":"<p>A blockchain consensus mechanism is a protocol that enables multiple participants in a blockchain network to agree on the current state of the blockchain and validate transactions without a centralised authority. By doing so, consensus mechanisms ensure the security of the blockchain and validate the authenticity of transactions.</p> <p>ParallelChain Mainnet uses a variant of consensus procotol called HotStuff to validate transactions on the network.</p>","tags":["Consensus","hotstuff.rs"]},{"location":"fundamentals/consensus_mechanism/#the-hotstuff-consensus-protocol","title":"The HotStuff Consensus Protocol","text":"<p>HotStuff works by building a 'BlockTree': a directed acyclic graph of Blocks. Block is a structure with a <code>data</code> field which applications are free to populate with arbitrary byte-arrays. In consensus algorithm literature, we typically talk of consensus algorithms as maintaining state machines that change their internal states in response to commands, hence the choice of terminology.</p> <p>HotStuff guarantees that committed Blocks are immutable. That is, they can never be un-committed as long as at least a supermajority of voting power faithfully executes the protocol. This guarantee enables applications to make hard-to-reverse actions with confidence. </p> <p></p> <p>A Block becomes committed the instant its third confirmation is written into the BlockTree. Confirmation for a Block <code>A</code> is another Block <code>B</code> such that there is a path between <code>B</code> to <code>A</code>.</p> <p>The choice of third confirmation to define commitment--as opposed to first or second--is not arbitrary. HotStuff's safety and liveness properties hinge upon this condition. You can read this paper to learn more about it. To summarize:</p> <ol> <li>Classic BFT consensus algorithms such as PBFT require only 2 confirmations for commitment, but this comes at the cost of expensive leader-replacement flows.</li> <li>Tendermint requires only 2 confirmations for commitment and has a simple leader-replacement flow, but needs an explicit 'wait-for-N seconds' step to guarantee liveness.</li> </ol> <p>HotStuff is the first consensus algorithm with a simple leader-replacement algorithm that does not have a 'wait-for-N seconds' step and thus can make progress as fast as network latency allows.</p>","tags":["Consensus","hotstuff.rs"]},{"location":"fundamentals/consensus_mechanism/#hotstuff-rs","title":"Hotstuff-rs","text":"<p>HotStuff-rs is a Rust Programming Language implementation of the HotStuff consensus protocol. It offers:</p> <ol> <li>Guaranteed Safety and Liveness in the face of up to 1/3rd of Voting Power being Byzantine at any given moment,</li> <li>A small API (<code>Executor</code>) for plugging in state machine-based applications like blockchains, and</li> <li>Well-documented, 'obviously correct' source code, designed for easy analysis and extension.</li> </ol> <p>A Rust Programming Language library for Byzantine Fault Tolerant state machine replication, intended for production  systems. </p> <p>HotStuff-rs implements a variant of the HotStuff consensus protocol, but with extensions like block-sync and dynamic validator sets that make this library suited for real-world use cases (and not just research systems). Some desirable properties that HotStuff-rs has are:</p> <ol> <li>Provable Safety in the face of up to 1/3rd of voting power being Byzantine at any given moment.</li> <li>Optimal Performance: consensus in (amortized) 1 round trip time.</li> <li>Simplicity: A small API (App) for plugging in arbitrary stateful applications.</li> <li>Modularity: pluggable networking, state persistence, and view-synchronization mechanism.</li> <li>Dynamic Validator Sets that can update without any downtime based on state updates: a must for PoS blockchain     applications.</li> <li>Batteries included: comes with a block-sync protocol and (coming soon) default implementations for networking,    state, and pacemaker: you write the app, and we handle the replication.</li> </ol>","tags":["Consensus","hotstuff.rs"]},{"location":"fundamentals/gas/","title":"Gas","text":"<p>Gas is a representation of the cost incurred by resources per transaction in the ParallelChain Mainnet ecosystem. Every transaction is assigned a cost through gas metering.</p> <p>There are different categories of gas cost in the ParallelChain Mainnet ecosystem:</p> <ul> <li>WASM opcode execution inside a contract call</li> <li>Reading and writing WASM memory from host functions inside a contract call</li> <li>Transaction-related data storage</li> <li>World state storage and access</li> <li>Cryptographic operations</li> </ul> <p>Details about gas can be found in ParallelChain Mainnet Protocol.</p>","tags":["gas","base fee formula","gas estimation"]},{"location":"fundamentals/gas/#how-are-gas-fees-calculated","title":"How are Gas Fees Calculated?","text":"<p>Gas Fee here refers to the amount that is paid with the account's balance for the gas consumed in transaction execution. It can be generalized by the following equation:</p> <pre><code>Gas Fee = Gas Consumption x (Base Fee Per Gas + Priority Fee Per Gas)\n</code></pre> <ul> <li><code>Gas Consumption</code> is the gas unit consumed during the transaction execution. </li> <li><code>Base Fee Per Gas</code> is the dynamically adjusted value that depends on the traffic of the network at the time of transaction execution. Please see the section Base Fee Formula in ParallelChain Mainnet Protocol for details.</li> <li><code>Priority Fee Per Gas</code> is the amount specified in the transaction by the signer, which is transferred to block producer, on per-gas basis.</li> </ul>","tags":["gas","base fee formula","gas estimation"]},{"location":"fundamentals/gas/#gas-estimation","title":"Gas Estimation","text":"<p>Transaction can fail for setting the Gas limit too low. There is no absolute answer to what gas limit should be specified. In general, the gas limit must be greater than Transaction Inclusion Cost and smaller than Block Gas Limit (500000000).</p> <p>The following table summaries on estimated gas consumption of different transaction commands:</p> Command Estimation Transfer 166,350 Deploy Contract size of contract bytecode * 2600 Call Contract Varies a lot depends on contract implementation Create Deposit 216,370 Topup Deposit 185,630 Set Deposit Setting 159,560 Withdraw Deposit 4,000,000 (varies a lot depends on the state of the pools) Stake 4,000,000 (varies a lot depends on the state of the pools) Unstake 4,000,000 (varies a lot depends on the state of the pools) <p>The above values are calulated by including the transaction inclusion cost (Assume one transaction with one command). It is estimated based on experiments in ParallelChain Mainnet version as of the date on 11-May-2023.</p>","tags":["gas","base fee formula","gas estimation"]},{"location":"fundamentals/networks/","title":"Networks","text":"","tags":["ParallelChain Mainnet","ParallelChain Testnet","Testnet 4","Explorer","Xperience Broswer Extension"]},{"location":"fundamentals/networks/#parallelchain-mainnet","title":"ParallelChain Mainnet","text":"<p>ParallelChain Mainnet is a high-performance blockchain designed for enterprise-level use cases. It provides a platform for developers to build decentralised applications (dApps) with its efficient smart contract execution engine.</p> <p>It is designed to balance high performance and genuine decentralization. It is protected by the a Byzantine Fault Tolerant (BFT) consensus protocol, which adopts a sophisticated class-based node system to ensure fast and accountable consensus.</p> <p>For more information about the consensus protocol, please read the section Consensus Mechanism.</p>","tags":["ParallelChain Mainnet","ParallelChain Testnet","Testnet 4","Explorer","Xperience Broswer Extension"]},{"location":"fundamentals/networks/#parallelchain-testnet","title":"ParallelChain Testnet","text":"<p>To ensure the new features in ParallelChain Mainnet have what it takes to survive decentralised deployment, they must first be battle-tested. This is where ParallelChain Testnet comes into play by allowing developers, or simply users, to develop and run smart contracts or transactions on ParallelChain and experiment with the blockchain, at no cost.</p> <p>Both Mainnet and Testnet are accessible through Explorer. But only onTestnet, a service called Faucet Service provides free tokens to users.</p>","tags":["ParallelChain Mainnet","ParallelChain Testnet","Testnet 4","Explorer","Xperience Broswer Extension"]},{"location":"fundamentals/networks/#accessing-the-networks","title":"Accessing the Networks","text":"<p>There are two client tools for accessing Mainnet and Testnet. </p> <ul> <li>ParallelChain Explorer: Web-based tool with a crypto wallet for interacting with Mainnet and Testnet.</li> <li>Xperience Browser Extension: Browser Extension of the ParallelChain Explorer Wallet.</li> </ul>","tags":["ParallelChain Mainnet","ParallelChain Testnet","Testnet 4","Explorer","Xperience Broswer Extension"]},{"location":"fundamentals/networks/#parallelchain-explorer","title":"ParallelChain Explorer","text":"<p>ParallelChain Explorer is a web-based tool integrated with the ParallelChain Mainnet ecosystem, which allows users to visualize and interact with the Mainnet and Testnet. By using the explorer, users can search for real-time and historical information about the blockchain. </p> <p>What you can do:</p> <ul> <li>Search and Navigation: Find specific blocks, transactions, and accounts easily by using block hash, transaction hash, and account address.</li> <li>Block Details: Explore details of specific blocks, including block height, timestamp, transaction information, etc.</li> <li>Transaction Details: Explore details of specific transactions, including signer/recipient account information, timestamp, consumed gas, etc.</li> <li>Account Details: Explore details of specific accounts, including nonce, contract count, transaction history, etc.</li> <li>Staking Details: Explore details of staking information for each pool, including operator, pool power, and commission rate, etc.</li> <li>Network Statistics: Gain insights into network-wide statistics, including gas consumption, block production time, reward issuance, etc.</li> <li>Wallet: Seamlessly create a ParallelChain wallet account and make transactions.</li> </ul> <p>Check out our ParallelChain Explorer!</p>","tags":["ParallelChain Mainnet","ParallelChain Testnet","Testnet 4","Explorer","Xperience Broswer Extension"]},{"location":"fundamentals/networks/#xperience-browser-extension","title":"Xperience Browser Extension","text":"<p>Xperience Browser Extension is a browser extension that allows you to integrate your dApp with ParallelChain Wallet.</p> <p>This enables your dapp to interact with your dapp users' XPLL accounts, to:</p> <ul> <li>Send transactions</li> <li>Stake XPLL</li> <li>Trigger confirmation for smart contract calls </li> </ul> <p>The browser extension is available on the Chrome Web Store now.</p>","tags":["ParallelChain Mainnet","ParallelChain Testnet","Testnet 4","Explorer","Xperience Broswer Extension"]},{"location":"fundamentals/networks/#faucet-service","title":"Faucet Service","text":"<p>The Faucet Service of our Testnet issues free testing tokens to users to test the blockchain network on Testnet.</p> <p>To obtain testing tokens, create your Testnet account first. Account can be easily created by using Web Wallet in ParallelChain Explorer (See here), or Xperience Browser Extension (See here).</p> <p>The created account should have an empty balance initially. You can request free tokens from Faucet Service.</p>","tags":["ParallelChain Mainnet","ParallelChain Testnet","Testnet 4","Explorer","Xperience Broswer Extension"]},{"location":"fundamentals/nodes/","title":"Nodes","text":"<p>ParallelChain Lab currently operates 10 validator nodes. They are all in the same node type - Fullnode.</p> <p>Fullnode is node software that stores and maintains a full copy of the blockchain. The specification can be found in the ParallelChain Mainnet Protocol. </p> <p>Fullnode starts with exchanging messages with other nodes in a P2P Network. Through a Consensus Machanism, it produces and validates blocks by executing transactions. The execution takes place in a component call Runtime which transits the state of the blockchain. The resulting state is then stored in a data structure called World State.</p> <p>Fullnode also runs a HTTP server to serve RPC requests. Transactions can be submitted in the RPC request. Fullnode buffers those transactions in the Mempool, and then waits for executing them.</p>","tags":["nodes","runtime","world state","p2p","mempool"]},{"location":"fundamentals/nodes/#runtime","title":"Runtime","text":"<p>The Runtime is the component in the ParallelChain protocol which executes transactions.</p> <p>Runtime can be considered as a Transition Function that deterministically executes transactions. Execution of the transition function proceeds through three phases: Pre-Charge, Commands, and Charge. The sequence flow of the pre-charge and charge phases are common to all transactions, while the sequence flow of the commands phase varies according to the composition of a transaction's vector of commands.</p> <p></p> <ul> <li>Pre-Charge Phase: makes simple checks to ensure that the transaction can be included in the block.</li> <li>Commands Phase: executes the sequence of commands included in the transaction.</li> <li>Charge Phase: performs settlement of balances for charging the total gas used in previous phases.</li> </ul>","tags":["nodes","runtime","world state","p2p","mempool"]},{"location":"fundamentals/nodes/#world-state","title":"World State","text":"<p>The World State is a set of key-value tuples representing the state of every account, stored inside a set of Merkle Patricia Trie (MPT) data structures. Key-value tuples can be inserted to a MPT. The MPT in return computes a hash value called state hash that is deterministic to all the data that it has. </p> <p>ParallelChain Protocol uses two kinds of MPT:</p> <ul> <li>Accounts Trie: The singular Accounts Trie. It stores the fields such as Nonce and Balance of all the accounts in the blockchain. </li> <li>Storage Tries: Unlike the <code>Accounts Trie</code>, there can be many <code>Storage Tries</code>. It stores key-value tuples associated with a specific account. These accounts are generally the Contract Accounts which inserts the key-value tuples according to its Contract implementation. It is also used by a special account called Network Account.</li> </ul>","tags":["nodes","runtime","world state","p2p","mempool"]},{"location":"fundamentals/nodes/#p2p-network","title":"P2P Network","text":"<p>ParallelChain Network is a peer-to-peer networking (P2P) component for ParallelChain replicas. It is built using libp2p which provides functionalities of messaging and peer discovery.</p> <ul> <li>Messaging: P2P enables replicas to send messages to each other to replicate the state machine, maintain a pool of pending transactions, as well as notify each other of dropped transactions.</li> <li>Peer Discovery: in order for messages to eventually be received by all of their intended recipients, the P2P network needs to be connected. However, forming a connected network topology is challenging, because the number of replicas for any particular ParallelChain blockchain is unbounded and can far exceed the number of transport-layer connections that a computer can feasibly maintain. Starting from a small set of \"boot nodes\", P2P's peer discovery forms and maintains a connected network topology without requiring every replica to be aware of every other replica.</li> </ul>","tags":["nodes","runtime","world state","p2p","mempool"]},{"location":"fundamentals/nodes/#mempool","title":"Mempool","text":"<p>Mempool is a component of the blockchain network that keeps transactions that have not yet been added to a block. It can refer to two things:</p> <ul> <li>The mempool of validating nodes and fullnodes, which accepts pending transactions for future inclusion in a block. (Only validating nodes can create new blocks.)</li> <li>The set of not-yet-confirmed transactions that are stored in the individual mempools of nodes in the network. This set can vary between nodes due to network delays and partitions.</li> </ul>","tags":["nodes","runtime","world state","p2p","mempool"]},{"location":"fundamentals/nodes/#how-does-mempool-work","title":"How does Mempool Work?","text":"<p>When a transaction is submitted to the blockchain network, it is first sent to the mempool where it waits to be executed. The mempool acts like a queue, storing the pending transactions and arranging them to be executed by block producers. Transactions are prioritized based on how much the sender is willing to pay for network resources, which is indicated in a field called <code>Max Base Fee Per Gas</code> within the transaction. The higher the fee, the higher the priority of the transaction.</p>","tags":["nodes","runtime","world state","p2p","mempool"]},{"location":"fundamentals/nodes/#base-fee-per-gas-in-parallelchain-mainnet","title":"Base Fee Per Gas in ParallelChain Mainnet","text":"<p>In ParallelChain Mainnet, the <code>base fee per gas</code> is calculated according to the Base fee formula. This is nearly identical to Ethereum's EIP-1559 and shares the same purpose: adjust the cost of a transaction based on how busy the network is.</p> <p>Note</p> <p>Validator nodes in ParallelChain Mainnet provided at the initial Launch do not take <code>priority fee</code> into the ranking calculation.</p>","tags":["nodes","runtime","world state","p2p","mempool"]},{"location":"fundamentals/nodes/#max-base-fee-per-gas-and-eip-1559-in-ethereum","title":"Max Base Fee Per Gas and EIP-1559 in Ethereum","text":"<p>The priority ranking method based on the <code>Max Base Fee Per Gas</code> is a crucial component of the EIP-1559 model for transaction processing in Ethereum.</p> <p>In the EIP-1559 model, each transaction specifies two fees: the <code>base fee</code> and the <code>priority fee</code>. The <code>base fee</code> is dynamically determined by the network based on the current demand for block space and adjusts itself to keep block utilization at a target level. The <code>priority fee</code> is the amount that the user is willing to pay in addition to the base fee to prioritize their transaction.</p> <p>When a transaction is submitted to the network, it is placed in the mempool, and the <code>priority fee</code> value of the transaction is used to rank it. Transactions with higher priority fees are placed higher in the mempool, making them more likely to be included in the next block. However, unlike the traditional method of simply sorting transactions by the fee amount, EIP-1559 allows for more efficient use of block space by dynamically adjusting the <code>base fee</code>, which incentivizes users to pay only what they need to get their transaction included. This helps to prevent congestion and ensures that transactions are processed in an efficient and timely manner.</p>","tags":["nodes","runtime","world state","p2p","mempool"]},{"location":"fundamentals/staking/","title":"Staking","text":"<p>Staking is a process of holding a cryptocurrency or token as a way to support the operations of a blockchain network. It involves locking up a certain amount of tokens for a period of time to participate in the process of validating transactions, adding new blocks to the chain, and maintaining the security and integrity of the network.</p> <p>In return for staking, users may receive rewards in the form of additional tokens issued by the network. In Parallelchain Mainnet Proof-of-Stake (PoS) consensus algorithm, the voting power of a validator depends on the its stake amount, rather than the computational power they can provide, as in Proof-of-Work (PoW) algorithms.</p> <p>Elements inside a staking process include:</p> <ul> <li>Pool: represents an operator and its delegators who can combine their stakes as a whole. The stake amount reflects the voting power of the pool operator. The stake amount also determines the rewards earned from an epoch if the pool operator is a validator.</li> <li>Stake: the amount that a participant locks up as collateral to be contributed to a pool.</li> <li>Deposit: the locked balance used to determine the amount of stake.</li> </ul>","tags":["Staking"]},{"location":"fundamentals/staking/#how-staking-works","title":"How Staking Works","text":"<p>In this staking process, there are two main actors: pool operators and owner. A pool operator can create, update, and destroy pools. An owner can deposit their XPLL into a pool, top-up their deposit, withdraw their deposit, and set the amount they want to stake in the pool. However, they cannot stake more than the amount they have deposited.</p> <p>If a pool has enough power (determined by the amount of stakes), it can join as a validator in the next epoch. In each epoch, block rewards are distributed to owners' deposits, and the validator set is updated according to the validators' power, which will determine the validators in consensus for the current epoch.</p> <p>An owner can withdraw their deposit from a pool, but the amount they withdraw cannot make their deposit less than the maximum stake amount in the current and previous epoch.</p>","tags":["Staking"]},{"location":"fundamentals/staking/#validator","title":"Validator","text":"<p>In a delegated proof-of-stake (DPoS) blockchain network, a validator is a participant in the network who is responsible for validating transactions and creating new blocks. To validate transactions, validators must check that the transaction is valid, for example, the sender has enough balance to complete the transaction.</p> <p>Validators are selected based on the amount of tokens they hold and their stake in the network. This stake serves as collateral and incentivizes validators to act honestly and maintain the security of the network. The more stakes they have, the greater their chances of being selected to be one of the validators in the next epoch.</p>","tags":["Staking"]},{"location":"fundamentals/staking/#delegator","title":"Delegator","text":"<p>In a delegated proof-of-stake (DPoS) blockchain network, a delegator is a participant who delegates their tokens to a staking pool. Delegators do not validate transactions or create new blocks themselves, but they can participate in the network's consensus process by proxy through a pool.</p> <p>Delegating tokens to a pool allows the delegator to earn rewards, for doing so, without having to run nodes themselves. Delegators typically choose a pool based on their reputation, track record, and the commission fee they charge. The exact amount of rewards earned may depend on various factors, such as the number of tokens staked, the length of time the tokens are staked for, and the network's overall performance.</p> <p>See also:</p> <ul> <li>Staking XPLL by Web Wallet</li> <li>Staking XPLL by Xperience Browser Extension</li> </ul>","tags":["Staking"]},{"location":"fundamentals/staking/#rewards","title":"Rewards","text":"<p>Rewards serve as an incentive for validators who actively contribute to the creation of new blocks within the blockchain network. </p> <p>In DPoS blockchains, validators are selected to validate transactions and generate new blocks based on the quantity of XPLL they have staked within the network. As a reward for their contributions, validators receive two kinds of rewards: 1. Priority Fees: an amount of existing XPLL that transaction signers transfer to block proposers to reward them for including their transaction. 2. Block Rewards: an amount of new XPLL created (\"issued\") at the end of every epoch according to a function of the total amount of XPLL staked.</p> <p>Block rewards play a crucial role in blockchain networks by serving multiple purposes. They incentivize miners and validators' participation in the network's consensus process, thereby upholding the security and integrity of the network. Additionally, block rewards facilitate the introduction of new XPLL into circulation, ensuring the long-term sustainability of the network.</p> <p>This document provides a rough overview of the calculation of block rewards. The exact formulas that Fullnodes use to calculate rewards are specified near the end of the \"next epoch\" section of the Runtime chapter of the ParallelChain Protocol specification.</p>","tags":["Staking"]},{"location":"fundamentals/staking/#reward-rate","title":"Reward Rate","text":"<p>The block reward amount gradually decreases as additional blocks are incorporated into the blockchain over time. This process, which is known as the block reward reduction, is a characteristic found in various blockchain networks, such as Bitcoin (where it is popularly called \"halving\"). By implementing the block reward reduction, the supply of cryptocurrency is regulated, effectively curbing inflationary pressures.</p> <p>Block rewards in ParallelChain Mainnet gradually reduce according to the following formula:</p> <ul> <li>First year: 8% per annum</li> <li>Reduce 15% per annum</li> <li>After 10 year (3650 days): keep at 1.5% per annum</li> </ul> <p>The total amount of rewards (issuance) introduced to the network is calculated as follows:</p> \\[ \\text{Total amount of stake} \\times \\text{Issuance rate} \\] <p>For example, if the total amount of stake of a validator is <code>100,000 XPLL</code> currently, and the issuance rate is <code>0.001</code>, then the total amount of XPLL to be issued to that validator in the next epoch will be <code>100,000 * 0.001 = 100 XPLL</code>.</p> <p>The issuance rate is calculated as follows:</p> \\[ \\text{Issuance rate at n-th epoch} = 0.0835 \\times \\frac{0.85^{\\frac{n}{365}}}{365} \\] <p>after 10 years (or equivalently, after \\(n &gt;= 3650\\)), the issuance rate will become a constant:</p> \\[ \\text{Issuance rate per epoch after 10 years} = \\frac{0.0150}{365}  \\]","tags":["Staking"]},{"location":"fundamentals/staking/#delegator-reward","title":"Delegator Reward","text":"<p>Delegators receive a portion of the newly issued rewards based on the amount they have staked with the validator. However, it's important to note that the delegator rewards will be reduced by a commission fee, which is determined by the validator and can be adjusted in their settings.</p> <p>Let's assume that in the upcoming epoch, the validator <code>V</code> will receive a total reward of <code>100 XPLL</code>. <code>V</code> has set a commission fee of <code>1%</code>. Additionally, one of its delegators, <code>D</code>, has contributed <code>10%</code> of the total staked amount to <code>V</code>. Then in the next epoch, <code>D</code> will be rewarded:</p> \\[ \\text{Reward} = 100 \\text{ XPLL} \\times 10\\% \\times (100\\% - 1\\%) = 9.99 \\text{ XPLL} \\]","tags":["Staking"]},{"location":"fundamentals/staking/#faq","title":"FAQ","text":"","tags":["Staking"]},{"location":"fundamentals/staking/#why-am-i-not-able-to-stake-xpll-tokens","title":"Why am I not able to stake XPLL tokens?","text":"<p>You will need to retain a certain amount of XPLL in your account balance to pay for transaction fees. Ensure that you have reserved a small amount of XPLL tokens to pay for the gas fee of your deposit, stake, or unstake XPLL tokens.</p>","tags":["Staking"]},{"location":"fundamentals/staking/#how-do-i-know-which-validator-to-stake-with","title":"How do I know which validator to stake with?","text":"<p>The validators securing the ParallelChain Mainnet are trusted participants who are required to stake a significant number of XPLL. You may check the yield and commission fee of each validator by looking into their account details on ParallelChain Explorer.</p>","tags":["Staking"]},{"location":"fundamentals/staking/#how-long-is-the-unstaking-period","title":"How long is the unstaking period?","text":"<p>The staking duration is measured by epochs. If you stake and unstake within the same epoch, the waiting time is considerably shorter. If the staking and unstaking are not within the same epoch, you will need to wait for at least another two epochs before unstaking.</p>","tags":["Staking"]},{"location":"fundamentals/staking/#how-long-is-an-epoch","title":"How long is an Epoch?","text":"<p>One full epoch lasts approximately one day before it enters the next epoch. The epoch itself is a protocol-defined period for measuring the performance of operators on the network.</p>","tags":["Staking"]},{"location":"fundamentals/staking/#how-do-i-withdraw-my-staking-rewards","title":"How do I withdraw my staking rewards?","text":"<p>You can withdraw the rewards you have earned from staking by unstaking them to your Token Deposit. Additionally, you may toggle the <code>AUTO STAKE REWARDS</code> to avoid the process of unstaking your rewards. From there, you can then withdraw the amount to your wallet. Please refer to the section on Unstaking Your XPLL and Withdrawing Your Staking Rewards for the required steps.</p>","tags":["Staking"]},{"location":"fundamentals/staking/#can-i-move-my-staked-xpll-to-another-validator","title":"Can I move my staked XPLL to another validator?","text":"<p>Yes, you can. You will need to unstake your XPLL tokens, withdraw them to the Token Deposit, and then back to your wallet. You can then transfer those tokens to a Token Deposit with another validator before staking your tokens with them. Please refer to the sections above to move your XPLL to another validator.</p>","tags":["Staking"]},{"location":"fundamentals/staking/#can-i-stake-to-more-than-one-node","title":"Can I stake to more than one node?","text":"<p>Yes, you can. To do so, you will need to create a Token Deposit on the validator node you wish to stake with. Once done, you can stake tokens with the validator node. To stake XPLL with more than one validator, repeat the same process of creating a Token Deposit with the other validator node, deposit tokens from your account to the Token Deposit, and you can stake with the second validator. Repeat this process with other validator nodes you wish to stake with.</p>","tags":["Staking"]},{"location":"fundamentals/staking/#the-status-is-still-showing-pending-why-is-my-transaction-not-confirmed-yet","title":"The status is still showing <code>PENDING</code>. Why is my transaction not confirmed yet?","text":"<p>Transactions are prioritized by the amount of Priority Fee per Gas paid, and lower priority transactions may need more time to be confirmed. You may choose to pay a higher Priority Fee during peak periods for a faster transaction, or you may check your wallet address on the ParallelChain Explorer to monitor its transaction status.</p>","tags":["Staking"]},{"location":"fundamentals/staking/#are-the-rewards-automatically-staked","title":"Are the rewards automatically staked?","text":"<p>Depends on the setting of your stake. Your staking rewards will not be automatically staked unless the AUTO STAKE REWARDS field is toggled on. You can toggle it on or off anytime you want.</p>","tags":["Staking"]},{"location":"fundamentals/staking/#is-there-any-locking-period","title":"Is there any locking period?","text":"<p>There is no locking period to stake your XPLL tokens, but the staking duration is measured by epochs. If you stake and unstake within the same epoch, the waiting time is considerably shorter. If the staking and unstaking are not within the same epoch, you will need to wait for at least another two epochs before unstaking.</p>","tags":["Staking"]},{"location":"fundamentals/transactions/","title":"Transactions","text":"<p>A transaction is a digitally signed instruction that tells the Mainnet state machine to execute a sequence of commands. </p> <p>A transaction has the following fields:</p> <ul> <li><code>Signer</code>: the public address of the external-owned account that signed this transaction.</li> <li><code>Nonce</code>: the number of transactions signed by the signer that has been included on the blockchain before this transaction. This ensures that all of the signer\u2019s transactions are included in the blockchain in an expected order and prevents the same transaction from being included in multiple blocks.</li> <li><code>Commands</code>: a sequence of Commands to be executed in a transaction.</li> <li><code>Gas Limit</code>: the maximum number of gas units that should be used in executing this transaction.</li> <li><code>Max Base Fee per Gas</code>: the maximum number of grays that the signer is willing to burn for a gas unit used in this transaction.</li> <li><code>Priority Fee per Gas</code>: the number of grays that the signer is willing to pay the block proposer for including this transaction in a block.</li> <li><code>Signature</code>: the signature formed by signing over content in this transaction using the signer\u2019s private key.</li> <li><code>Hash</code>: the cryptographic hash of the signature.</li> </ul> <p>Example of a transaction queried by ParallelChain Client CLI:</p> <pre><code>{\n  \"transaction\": {\n    \"commands\": [\n      {\n        \"Transfer\": {\n          \"recipient\": \"kxrCl32WEzr7gr4Awb3jAMQtoh5zY8grabqlu-x42jY\",\n          \"amount\": 2000000000\n        }\n      }\n    ],\n    \"signer\": \"qPReY5x_DPKAx1v30UrU1x1RI61Wd2OxeZo2eSWcjMU\",\n    \"priority_fee_per_gas\": 0,\n    \"gas_limit\": 67500000,\n    \"max_base_fee_per_gas\": 8,\n    \"nonce\": 428,\n    \"hash\": \"dOrjtT7o5Y97mlLJFaCvdNUq6UgVQItVYGXHPoDw5n4\",\n    \"signature\": \"RLM3k5VDDzBqkQ7ios4TMP9LwL50n8hNQ7OjH-wcTE0Ts6F3uWDaA5J52sCyYr3aGGGElXKiIatqH15qVwMUAA\"\n  },\n  \"receipt\": [\n    {\n      \"status_code\": \"Success\",\n      \"gas_used\": 32820,\n      \"return_values\": \"\",\n      \"logs\": []\n    }\n  ]\n}\n</code></pre>","tags":["Transaction","Receipt","Nonce","Exit Status","Log"]},{"location":"fundamentals/transactions/#how-transaction-works","title":"How Transaction Works","text":"<p>A transaction is created by an EOA who sets the fields such as <code>nonce</code>, <code>gas_limit</code> of a transaction. The field <code>signer</code> is the address (public key) of the account, and the signature is created by signing the the content of the transaction with the private key of the account. Finally, the field <code>hash</code> is computed from the signature field.</p> <p>EOA submits transaction to the blockchain network. The nodes will then execute the transaction in order to produce a block. The transaction execution mutates the state of blockchain. For example, if the transaction includes a Transfer Command, balances of the signer and recipient can be updated upon a successful execution.</p> <p>In the end, the transaction becomes part of a block if it is executed and validated successfully, Otherwise, the transaction will be dropped by the network.</p> <p>See also:</p> <ul> <li>Create Transaction by CLI</li> <li>Transferring Tokens by Web Wallet</li> <li>Transferring Tokens by Xperience Browser Extension</li> </ul>","tags":["Transaction","Receipt","Nonce","Exit Status","Log"]},{"location":"fundamentals/transactions/#commands","title":"Commands","text":"<p>A command is a useful operation that Parallelchain allows the user to do. A sequence of commands can be inserted into a transaction to be carried out. There are currently 13 different kinds of commands, each corresponding to a variant of the command enum type. These are further divided into three categories: account commands, staking commands, and protocol commands. Most commands take inputs, which are part of the command type as the fields of its corresponding variant.</p> <p>In the below subsections, the input types are represented in Rust programming language. For example, <code>PublicAddress</code> is 32-byte data. <code>Vec&lt;u8&gt;</code> is vector of unsigned 8-bit integers (bytes). </p>","tags":["Transaction","Receipt","Nonce","Exit Status","Log"]},{"location":"fundamentals/transactions/#account-commands","title":"Account commands","text":"<p>Account commands are the commands specific to mutate state of Accounts in the blockchain.</p> Name Input Description Transfer <li>Recipient (<code>PublicAddress</code>)</li> <li>Amount (<code>u64</code>)</li> Transfer an amount from the signer's balance to the recipient's balance. Deploy <li>Contract (<code>Vec&lt;u8&gt;</code>)</li> <li>CBI version (<code>u32</code>)</li> Deploy a contract that implements a given CBI version. Call <li>Target (<code>PublicAddress</code>)</li> <li>method (<code>String</code>)</li> <li>arguments (<code>Option&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;</code>)</li> <li>amount (<code>Option&lt;u64&gt;</code>)</li> Call a contract method with given arguments, optionally transferring some tokens.","tags":["Transaction","Receipt","Nonce","Exit Status","Log"]},{"location":"fundamentals/transactions/#staking-commands","title":"Staking commands","text":"<p>Staking commands are mainly associated with the staking process in ParallelChain Mainnet ecosystem.</p> Name Input Description Create pool <li>Commission rate (<code>u8</code>)</li> Create a new pool with the signer as the operator which charges a given commission rate on the validator rewards of delegated stakes Set pool settings <li>Commission rate (<code>u8</code>)</li> Set the commission rate of an existing pool, operated by the signer. Delete pool <li>None</li> Delete an existing pool, as well as all of its existing stakes. Create Deposit <li>Operator (<code>PublicAddress</code>)</li> <li>Balance (<code>u64</code>)</li> <li>Auto stake rewards (<code>bool</code>)</li> Create a deposit that targets a given operator, with the given balance, and stake the validator rewards that it receives optionally. Set deposit settings <li>Operator (<code>PublicAddress</code>)</li> <li>Auto stake rewards? (<code>bool</code>)</li> Set whether a given deposit automatically stakes validator rewards. Top up deposit <li>Operator (<code>PublicAddress</code>)</li> <li>Balance (<code>u64</code>)</li> Transfer more tokens into an existing deposit. Withdraw Deposit <li>Operator (<code>PublicAdddress</code>)</li> <li>Max amount (<code>u64</code>)</li> Try to withdraw a given amount from a deposit into the signer's balance. Stake <li>Operator (<code>PublicAddress</code>)</li> <li>Max amount (<code>u64</code>)</li> Try to stake a given amount from a deposit. Unstake <li>Operator (<code>PublicAddress</code>)</li> <li>Max amount (<code>u64</code>)</li> Try to reduce a deposit's stake by a given amount. <p>Note</p> <p>The actual amount of tokens that could be withdrawn, staked, or unstaked by the final three kinds of commands depends on timing and order, factors that users do not have precise control over. For example, the number of tokens that can be withdrawn from a deposit can change significantly between epochs as the deposit's bonded balance decreases, or increases.</p> <p>Therefore, these commands accept as input a \"max amount\" instead of a precise amount. These commands try to withdraw, stake, or unstake as close to the maximum amount as possible, and inform the precise amount in its return value.</p>","tags":["Transaction","Receipt","Nonce","Exit Status","Log"]},{"location":"fundamentals/transactions/#protocol-commands","title":"Protocol commands","text":"<p>Protocol commands are the commands which mutates the state of the whole network (i.e. mutates the state of Network Account in the blockchain). The current protocol version has only one protocol command, <code>Next Epoch</code>.</p> Name Input Description Next epoch None Reward the current epoch's validators, and confirm the next epoch's validator set.","tags":["Transaction","Receipt","Nonce","Exit Status","Log"]},{"location":"fundamentals/transactions/#receipt-and-logs","title":"Receipt and Logs","text":"<p>A receipt is produced upon execution of each transaction. It consists of a sequence of <code>CommandReceipt</code>, which provides a succinct summary of what happened during the execution of the corresponding <code>Command</code> in a transaction.</p> <p>A Command Receipt has the following fields:</p> <ul> <li><code>Exit Status</code>: tells whether the corresponding command in the sequence succeeded in doing its operation and, if it failed, whether the failure is because of gas exhaustion or some other reason.</li> <li><code>Gas Used</code>: how much gas was used in the execution of the transaction. This will at most be the transaction\u2019s gas limit.</li> <li><code>Return Values</code>: the return values of the corresponding command.</li> <li><code>Logs</code>: the logs emitted during the corresponding call command.</li> </ul> <p>Possible values for <code>Exit Status</code> are:</p> Code Name Description 0x00 Operation successful The command successfully did what it is supposed to do. 0x01 Operation failed The command failed to do what it is supposed to do. 0x02 Gas exhausted Execution halted in the middle of the command because the gas limit was hit. <p>Logs are topic-value pairs emitted during smart contract execution. Logs allow decentralised applications to quickly prove to users that a particular branch/line of code was executed during a transaction, by querying for the existence of logs in blocks.</p>","tags":["Transaction","Receipt","Nonce","Exit Status","Log"]},{"location":"tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"tags/#account","title":"Account","text":"<ul> <li>Accounts</li> </ul>"},{"location":"tags/#block-header","title":"Block Header","text":"<ul> <li>Blocks</li> </ul>"},{"location":"tags/#cli","title":"CLI","text":"<ul> <li>Creating Transaction</li> <li>Getting Started</li> <li>Interacting with Smart Contract</li> <li>Managing Account</li> <li>Querying Blockchain</li> </ul>"},{"location":"tags/#client","title":"Client","text":"<ul> <li>JavaScript APIs</li> <li>Rust Client APIs</li> </ul>"},{"location":"tags/#consensus","title":"Consensus","text":"<ul> <li>Consensus Mechanism</li> </ul>"},{"location":"tags/#contract-methods","title":"Contract Methods","text":"<ul> <li>Contract Methods</li> </ul>"},{"location":"tags/#cross-contract-call","title":"Cross Contract Call","text":"<ul> <li>Cross Contract Call</li> </ul>"},{"location":"tags/#cryptographic-functions","title":"Cryptographic Functions","text":"<ul> <li>Cryptographic Functions</li> </ul>"},{"location":"tags/#eoa","title":"EOA","text":"<ul> <li>Accounts</li> </ul>"},{"location":"tags/#exit-status","title":"Exit Status","text":"<ul> <li>Transactions</li> </ul>"},{"location":"tags/#explorer","title":"Explorer","text":"<ul> <li>Networks</li> </ul>"},{"location":"tags/#javascript","title":"Javascript","text":"<ul> <li>JavaScript APIs</li> </ul>"},{"location":"tags/#log","title":"Log","text":"<ul> <li>Transactions</li> </ul>"},{"location":"tags/#mainnet","title":"Mainnet","text":"<ul> <li>Introduction</li> </ul>"},{"location":"tags/#network-account","title":"Network Account","text":"<ul> <li>Accounts</li> </ul>"},{"location":"tags/#nonce","title":"Nonce","text":"<ul> <li>Transactions</li> </ul>"},{"location":"tags/#prfc","title":"PRFC","text":"<ul> <li>PRFC</li> </ul>"},{"location":"tags/#parallelchain","title":"ParallelChain","text":"<ul> <li>Welcome to the ParallelChain Mainnet Documentation</li> <li>Introduction</li> </ul>"},{"location":"tags/#parallelchain-mainnet","title":"ParallelChain Mainnet","text":"<ul> <li>Networks</li> </ul>"},{"location":"tags/#parallelchain-rpc-api","title":"ParallelChain RPC API","text":"<ul> <li>JavaScript APIs</li> <li>Rust Client APIs</li> </ul>"},{"location":"tags/#parallelchain-testnet","title":"ParallelChain Testnet","text":"<ul> <li>Networks</li> </ul>"},{"location":"tags/#receipt","title":"Receipt","text":"<ul> <li>Transactions</li> </ul>"},{"location":"tags/#rust","title":"Rust","text":"<ul> <li>Rust Client APIs</li> <li>Installing SDK</li> </ul>"},{"location":"tags/#smart-contract","title":"Smart Contract","text":"<ul> <li>Getting Started</li> <li>Installing SDK</li> <li>Introduction</li> <li>PRFC</li> <li>Accessing Information About the Blockchain</li> <li>Contract Methods</li> <li>Contract Storage</li> <li>Cross Contract Call</li> <li>Cryptographic Functions</li> <li>Staking in Contract</li> <li>Hello Contract</li> <li>My Little Pony</li> <li>My Bank</li> <li>Contract Proxy</li> <li>My Collections</li> <li>My Pool</li> </ul>"},{"location":"tags/#staking","title":"Staking","text":"<ul> <li>Staking in Contract</li> <li>My Pool</li> <li>Staking</li> </ul>"},{"location":"tags/#testnet-4","title":"Testnet 4","text":"<ul> <li>Networks</li> </ul>"},{"location":"tags/#token-standard","title":"Token Standard","text":"<ul> <li>PRFC</li> </ul>"},{"location":"tags/#tools","title":"Tools","text":"<ul> <li>JavaScript APIs</li> <li>Rust Client APIs</li> <li>Creating Transaction</li> <li>Getting Started</li> <li>Interacting with Smart Contract</li> <li>Managing Account</li> <li>Querying Blockchain</li> </ul>"},{"location":"tags/#transaction","title":"Transaction","text":"<ul> <li>Transactions</li> </ul>"},{"location":"tags/#world-state","title":"World State","text":"<ul> <li>Contract Storage</li> </ul>"},{"location":"tags/#xperience","title":"Xperience","text":"<ul> <li>Creating and Managing Your Account</li> <li>Lock-Up Contract</li> <li>Staking XPLL</li> <li>Transferring Tokens</li> </ul>"},{"location":"tags/#xperience-broswer-extension","title":"Xperience Broswer Extension","text":"<ul> <li>Networks</li> </ul>"},{"location":"tags/#xperience-browser-extension","title":"Xperience browser extension","text":"<ul> <li>Creating and Managing Your Account</li> </ul>"},{"location":"tags/#xperience-extension","title":"Xperience extension","text":"<ul> <li>Lock-Up Contract</li> <li>Managing Tokens</li> <li>Staking XPLL</li> <li>Transferring Tokens</li> </ul>"},{"location":"tags/#base-fee-formula","title":"base fee formula","text":"<ul> <li>Gas</li> </ul>"},{"location":"tags/#browser-extension","title":"browser extension","text":"<ul> <li>API Reference</li> <li>Definitions</li> <li>Errors</li> <li>Events</li> <li>Introduction</li> <li>Permissions</li> </ul>"},{"location":"tags/#explorer_1","title":"explorer","text":"<ul> <li>Preparing Environment</li> <li>Creating and Managing Your Account</li> <li>Lock-Up Contract</li> <li>Staking XPLL</li> <li>Transferring Tokens</li> </ul>"},{"location":"tags/#gas","title":"gas","text":"<ul> <li>Gas</li> </ul>"},{"location":"tags/#gas-estimation","title":"gas estimation","text":"<ul> <li>Gas</li> </ul>"},{"location":"tags/#hotstuffrs","title":"hotstuff.rs","text":"<ul> <li>Consensus Mechanism</li> </ul>"},{"location":"tags/#internal-transaction","title":"internal transaction","text":"<ul> <li>Transferring Balance</li> </ul>"},{"location":"tags/#lockup-contract","title":"lockup contract","text":"<ul> <li>Lock-Up Contract</li> <li>Lock-Up Contract</li> </ul>"},{"location":"tags/#mainnet_1","title":"mainnet","text":"<ul> <li>Preparing Environment</li> <li>Transferring Balance</li> </ul>"},{"location":"tags/#mempool","title":"mempool","text":"<ul> <li>Nodes</li> </ul>"},{"location":"tags/#nodes","title":"nodes","text":"<ul> <li>Nodes</li> </ul>"},{"location":"tags/#p2p","title":"p2p","text":"<ul> <li>Nodes</li> </ul>"},{"location":"tags/#parallelchain-sdk","title":"parallelchain sdk","text":"<ul> <li>Transferring Balance</li> </ul>"},{"location":"tags/#pchain-cli-rust","title":"pchain-cli-rust","text":"<ul> <li>Creating Transaction</li> <li>Getting Started</li> <li>Interacting with Smart Contract</li> <li>Managing Account</li> <li>Querying Blockchain</li> </ul>"},{"location":"tags/#pchain-sdk","title":"pchain-sdk","text":"<ul> <li>Getting Started</li> <li>Installing SDK</li> <li>Introduction</li> <li>Accessing Information About the Blockchain</li> <li>Contract Methods</li> <li>Contract Storage</li> <li>Cross Contract Call</li> <li>Cryptographic Functions</li> <li>Staking in Contract</li> <li>Hello Contract</li> <li>My Little Pony</li> <li>My Bank</li> <li>Contract Proxy</li> <li>My Collections</li> <li>My Pool</li> </ul>"},{"location":"tags/#provider-api","title":"provider API","text":"<ul> <li>API Reference</li> <li>Definitions</li> <li>Errors</li> <li>Events</li> <li>Introduction</li> <li>Permissions</li> </ul>"},{"location":"tags/#runtime","title":"runtime","text":"<ul> <li>Nodes</li> </ul>"},{"location":"tags/#smart-contract_1","title":"smart contract","text":"<ul> <li>Transferring Balance</li> </ul>"},{"location":"tags/#staking_1","title":"staking","text":"<ul> <li>Staking XPLL</li> <li>Staking XPLL</li> </ul>"},{"location":"tags/#testnet","title":"testnet","text":"<ul> <li>Preparing Environment</li> </ul>"},{"location":"tags/#testnet-4_1","title":"testnet 4","text":"<ul> <li>Transferring Balance</li> </ul>"},{"location":"tags/#transaction_1","title":"transaction","text":"<ul> <li>Accessing Information About the Blockchain</li> </ul>"},{"location":"tags/#tutorial","title":"tutorial","text":"<ul> <li>Hello Contract</li> <li>My Little Pony</li> <li>My Bank</li> <li>Contract Proxy</li> <li>My Collections</li> <li>My Pool</li> </ul>"},{"location":"tags/#wallet","title":"wallet","text":"<ul> <li>API Reference</li> <li>Definitions</li> <li>Errors</li> <li>Events</li> <li>Introduction</li> <li>Permissions</li> </ul>"},{"location":"tags/#world-state_1","title":"world state","text":"<ul> <li>Nodes</li> </ul>"},{"location":"tags/#xpll","title":"xpll","text":"<ul> <li>Transferring Tokens</li> <li>Lock-Up Contract</li> <li>Managing Tokens</li> <li>Staking XPLL</li> <li>Transferring Tokens</li> </ul>"}]}